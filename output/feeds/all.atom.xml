<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>leelongcrazy's blog</title><link href="https://leelongcrazy.github.io/" rel="alternate"></link><link href="https://leelongcrazy.github.io/feeds/all.atom.xml" rel="self"></link><id>https://leelongcrazy.github.io/</id><updated>2021-03-14T18:00:00+08:00</updated><entry><title>关于我</title><link href="https://leelongcrazy.github.io/guan-yu-wo.html" rel="alternate"></link><published>2021-03-14T18:00:00+08:00</published><updated>2021-03-14T18:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2021-03-14:/guan-yu-wo.html</id><summary type="html">&lt;p&gt;我是leelongcrazy，有一个微信公众号：溧河弯弯。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;关于我&lt;/h1&gt;
&lt;h2&gt;我是谁&lt;/h2&gt;
&lt;p&gt;我是leelongcrazy，有一个微信公众号：溧河弯弯，关于我更多的故事，请移步这里&lt;img alt="qrcode" src="./images/qrcode.bmp"&gt;。&lt;/p&gt;
&lt;h2&gt;我为自己设计的一个logo&lt;/h2&gt;
&lt;p&gt;意图是这样的：在自己的能力圈内做事，持续的学习将关注圈的东西吸收为自己的能力，对外界一切未知的东西保持好奇，不断的探索延展学习圈的边界。&lt;/p&gt;
&lt;h2&gt;我的时间分配&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;8小时睡眠&lt;/li&gt;
&lt;li&gt;8小时工作&lt;/li&gt;
&lt;li&gt;8小时投资自己&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对我来讲，大部分时间我都在阅读和思考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读书：科技类，人物历史类的书居多&lt;/li&gt;
&lt;li&gt;读人：读书也是读人，听听自己所关注人的演讲&lt;/li&gt;
&lt;li&gt;读社会：关注这个社会动态的变化；&lt;/li&gt;
&lt;li&gt;读自己：写一些东西记录自己的状态；时常做一些对自己过去经历的复盘。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在我自由的时间里我可以无忧虑的思考我所思考的东西。&lt;/p&gt;
&lt;h2&gt;我所关注的技术领域&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;技术&lt;/li&gt;
&lt;li&gt;互联网科技（技术趋势）&lt;/li&gt;
&lt;li&gt;网络安全（web，Iot方向）&lt;/li&gt;
&lt;li&gt;编程技术（Python, C++, JavaScript）&lt;/li&gt;
&lt;li&gt;管理&lt;/li&gt;
&lt;li&gt;重要还是放在了经营自己&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我做的一个关于技术的站点：&lt;a href="https://leelongcrazy.com"&gt;leelongcrazy's site&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;我所关注的学科知识：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;教育学&lt;/li&gt;
&lt;li&gt;计算机科学&lt;/li&gt;
&lt;li&gt;数学&lt;/li&gt;
&lt;li&gt;物理学&lt;/li&gt;
&lt;li&gt;生物学&lt;/li&gt;
&lt;li&gt;政治学&lt;/li&gt;
&lt;li&gt;经济学&lt;/li&gt;
&lt;li&gt;历史学&lt;/li&gt;
&lt;li&gt;文学&lt;/li&gt;
&lt;li&gt;哲学&lt;/li&gt;
&lt;li&gt;社会学&lt;/li&gt;
&lt;li&gt;心理学&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;践行“通识为本，专识为末”的教育理念。通中有专，专中有通，是我的目标。&lt;/p&gt;
&lt;h2&gt;我的性格特征&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;我的MBTI类型：INFP&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理想化，忠诚&lt;/li&gt;
&lt;li&gt;思维开阔，有好奇心和洞察力，具有出色的长远的眼光&lt;/li&gt;
&lt;li&gt;具有忍耐力和适应性&lt;/li&gt;
&lt;li&gt;坚定的对待内心的忠诚，为自己设立了事实上几乎是不可能的标准&lt;/li&gt;
&lt;li&gt;富有同理心，理解力，对于别人的情感很敏感&lt;/li&gt;
&lt;li&gt;喜欢通过书写而不是口头来表达自己的感情&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;在工作中的优势&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;喜欢复杂理论及智力上的挑战&lt;/li&gt;
&lt;li&gt;有创造性解决问题的天资，能客观的审查问题&lt;/li&gt;
&lt;li&gt;对于在工作中胜任和胜出有强烈动机&lt;/li&gt;
&lt;li&gt;工作原则性强&lt;/li&gt;
&lt;li&gt;能创造出方法体系和模式来达到目标&lt;/li&gt;
&lt;li&gt;擅长从事技术性工作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;在工作中劣势&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;唐突，不机智，缺乏交际手段&lt;/li&gt;
&lt;li&gt;对一些世俗小事没有兴趣&lt;/li&gt;
&lt;li&gt;对自己的观点顽强的坚持&lt;/li&gt;
&lt;li&gt;对反应不如自己敏捷的人缺乏耐心&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;我是内向型的人&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;很多时间沉浸在自己的世界里，思考对我来说很重要。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其实有些时候我也是一个外向的人。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;我从哪里来&lt;/h2&gt;
&lt;p&gt;我从中原而来，对就是历史书中所讲的那个中原，也是金庸书中的讲的中原。我后来的学习去了福建，而今又来到广州，通过对这些地方的历史的了解，在这里生活的人和中原也有着不解之缘。&lt;/p&gt;
&lt;h2&gt;我的原则&lt;/h2&gt;
&lt;p&gt;知行合一&lt;/p&gt;
&lt;p&gt;行胜于言&lt;/p&gt;
&lt;p&gt;困难，但绝非不可能&lt;/p&gt;
&lt;p&gt;万物始于信息&lt;/p&gt;
&lt;p&gt;第一性原理&lt;/p&gt;
&lt;p&gt;看不见的手&lt;/p&gt;
&lt;h2&gt;可以和我聊什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;我感兴趣的学科领域的知识&lt;/li&gt;
&lt;li&gt;教育的意义&lt;/li&gt;
&lt;li&gt;中国哲学思想&lt;/li&gt;
&lt;li&gt;一切我还未知的东西都有兴趣聊&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;如果用一句话来形容自己，我会这样说&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;在我的身体里只流淌着三样东西：血，油和电。&lt;/strong&gt;&lt;/p&gt;</content><category term="Article"></category></entry><entry><title>web安全学习笔记</title><link href="https://leelongcrazy.github.io/weban-quan-xue-xi-bi-ji.html" rel="alternate"></link><published>2021-03-14T18:00:00+08:00</published><updated>2021-03-14T18:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2021-03-14:/weban-quan-xue-xi-bi-ji.html</id><summary type="html">&lt;p&gt;web渗透测试学习记录&lt;/p&gt;</summary><content type="html">&lt;h4&gt;渗透测试工程师：模拟黑客角度入侵企业以达到测试企业安全防御体系的目的。&lt;/h4&gt;
&lt;h5&gt;渗透测试是通过模拟恶意黑客的攻击方法，来评估计算机网络系统安全的一种评估方法。&lt;/h5&gt;
&lt;h5&gt;渗透测试是模拟黑客攻击测试，但两者也有区别，渗透测试是“面”的测试，黑客攻击是“深度”测试。前者涉及内容更加广泛，后者讲究的是破坏性。&lt;/h5&gt;
&lt;h2&gt;常见web安全漏洞&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;SQL注入漏洞&lt;/li&gt;
&lt;li&gt;命令（代码）注入&lt;/li&gt;
&lt;li&gt;跨站脚本注入XSS（Cross Site Script Inject）&lt;/li&gt;
&lt;li&gt;客户端请求伪造（CSRF）&lt;/li&gt;
&lt;li&gt;服务端请求伪造（SSRF）&lt;/li&gt;
&lt;li&gt;任意文件上传&lt;/li&gt;
&lt;li&gt;文件包含（LFI/RFI）&lt;/li&gt;
&lt;li&gt;XML实体注入 XXE&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;SQL注入漏洞&lt;/h2&gt;
&lt;h5&gt;SQL是用于访问和处理数据库的标准的计算机语言。SQL注入，就是把SQL命令插入到web表单提交或输入域名或页面请求的查询字符串，以达到欺骗服务器执行恶意SQL命令的目的。&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;SQL注入的分类&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;报错注入&lt;/li&gt;
&lt;li&gt;union注入&lt;/li&gt;
&lt;li&gt;时间盲注&lt;/li&gt;
&lt;li&gt;布尔盲注&lt;/li&gt;
&lt;li&gt;堆叠盲注&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;常见的注入语句：&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;‘ or 1=1&lt;/span&gt;
&lt;span class="err"&gt;‘ or 1=1#&lt;/span&gt;
&lt;span class="err"&gt;‘ or 1=1- -&lt;/span&gt;
&lt;span class="err"&gt;‘ or 1=1/*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://raw.githubusercontent.com/TheKingOfDuck/fuzzDicts/master/sqlDict/sql.txt"&gt;【SQL注入字典】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://twosecurity-resource.oss-cn-hangzhou.aliyuncs.com/resources/MySQL_5.1_Reference_Manual-zh-Function_and_Operator.pdf"&gt;【MySQL 5.1 中文参考手册】&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;命令注入漏洞&lt;/h2&gt;
&lt;h6&gt;通过提交恶意构造的参数，破坏命令语句结构，从而达到执行恶意命令的目的。&lt;/h6&gt;
&lt;h2&gt;XSS攻击&lt;/h2&gt;
&lt;h6&gt;全称Cross Site Scripting，跨站脚本。&lt;/h6&gt;
&lt;h6&gt;XSS攻击主要分为三类：&lt;/h6&gt;
&lt;ol&gt;
&lt;li&gt;反射性XSS&lt;/li&gt;
&lt;li&gt;存储型XSS（最隐蔽的攻击类型）&lt;/li&gt;
&lt;li&gt;DOM型XSS&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;上述三种类型的XSS也可以根据输出点的不同分为三类：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输出在html属性中&lt;/li&gt;
&lt;li&gt;输出在CSS代码中&lt;/li&gt;
&lt;li&gt;输出在JavaScript中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;XSS盲注的特点：&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;通常不会立即触发；&lt;/li&gt;
&lt;li&gt;通常无任何及时响应；&lt;/li&gt;
&lt;li&gt;是否XSS注入成功未知；&lt;/li&gt;
&lt;li&gt;危险系数较高。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;XSS的防御&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;http-only设置，导致拿不到cookie&lt;/li&gt;
&lt;li&gt;对用户输入进行过滤&lt;/li&gt;
&lt;li&gt;对用户输出进行过滤&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;常用的XSS语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;svg&lt;/span&gt; &lt;span class="na"&gt;onload&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;alert(1)&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
直接输出HTML
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;input&lt;/span&gt; &lt;span class="na"&gt;value&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;autofocus onfocus=alert(1)//&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
未过滤，输出在input框中
value=&amp;quot;&amp;quot;&amp;gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;svg&lt;/span&gt; &lt;span class="na"&gt;onload&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;alert(&amp;quot;XSS&amp;quot;)//&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
未过滤，其他属性值中
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;/&amp;quot;;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
未过滤，输出在JS变量中
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;website&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;xxxx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;/&amp;quot;;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
未过滤，输出在JS变量中
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;绕过XSS过滤的方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;大小写：&lt;code&gt;&amp;lt;sCriPt&amp;gt;alert(1)&amp;lt;/sCriPt&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组合过滤:&lt;code&gt;&amp;lt;scr&amp;lt;script&amp;gt;ipt&amp;gt;alert(1)&amp;lt;/sc&amp;lt;script&amp;gt;ript&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出在JS中：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JS单行注释：利用换行符，回车符-》&lt;code&gt;%0d, %0a&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JS多行注释：利用多行注释符，&lt;code&gt;*/&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;URL编码：&lt;code&gt;encodeURIComponent("&amp;lt;svg onload=alert(1)&amp;gt;") "%3Csvg%20onload%3Dalert(1)%3E"&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;XSS本地存储：&lt;code&gt;localStorage.setItem()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;XSS 攻击的要点：构造XSS payload，打破html结构，使其出错，利用错误信息进一步完善payload以达到攻击目的。&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;可能回遇到的困难：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;语句过长，输入长度受限；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有过滤机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有Waf&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;URL Redirect URL重定向漏洞&lt;/h4&gt;
&lt;p&gt;URL跳转，URL重定向漏洞，由于目标网站未对程序跳转的URL地址及参数做合法性判断，导致应用程序直接跳转到参数中指定的URL地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;危害：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可将跳转URL地址修改为指向恶意地址，即可发起网络钓鱼、诈骗甚至窃取用户凭据等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见的应用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主要是业务逻辑中需要进行跳转的地方。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比如登录处，注册处，访问用户信息，订单信息，加入购物车，分享，收藏等处。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;// URL跳转参数&lt;/span&gt;
&lt;span class="err"&gt;redirect&lt;/span&gt;
&lt;span class="err"&gt;url&lt;/span&gt;
&lt;span class="err"&gt;redirectUrl&lt;/span&gt;
&lt;span class="err"&gt;callback&lt;/span&gt;
&lt;span class="err"&gt;return_url&lt;/span&gt;
&lt;span class="err"&gt;toUrl&lt;/span&gt;
&lt;span class="err"&gt;ReturnUrl&lt;/span&gt;
&lt;span class="err"&gt;fromUrl&lt;/span&gt;
&lt;span class="err"&gt;redUrl&lt;/span&gt;
&lt;span class="err"&gt;request&lt;/span&gt;
&lt;span class="err"&gt;redirect_to&lt;/span&gt;
&lt;span class="err"&gt;redirect_url&lt;/span&gt;
&lt;span class="err"&gt;jump&lt;/span&gt;
&lt;span class="err"&gt;jump_to&lt;/span&gt;
&lt;span class="err"&gt;target&lt;/span&gt;
&lt;span class="err"&gt;targetUrl&lt;/span&gt;
&lt;span class="err"&gt;to&lt;/span&gt;
&lt;span class="err"&gt;goto&lt;/span&gt;
&lt;span class="err"&gt;link&lt;/span&gt;
&lt;span class="err"&gt;linkto&lt;/span&gt;
&lt;span class="err"&gt;domain&lt;/span&gt;
&lt;span class="err"&gt;oauth_callback&lt;/span&gt;
&lt;span class="err"&gt;referrerdomain&lt;/span&gt;
&lt;span class="err"&gt;next&lt;/span&gt;
&lt;span class="err"&gt;service&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Google serarch 大法&lt;/h3&gt;
&lt;p&gt;inurl:redirect_url intitle:登录 -"keywords" -"博客" -"wordpress" -"blog" intext:验证码&lt;/p&gt;
&lt;h2&gt;SSRF&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Server-Side Request Forgery&lt;/strong&gt;:服务器端请求伪造，攻击者构造成服务端发起请求的一个安全漏洞。
形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤和限制。
SSRF漏洞一般位于远程图片加载与下载、图片或文章收藏功能、URL分享、通过URL在线翻译、转码等功能点处。&lt;/p&gt;
&lt;h2&gt;文件包含&lt;/h2&gt;
&lt;p&gt;程序猿通常会把可重复使用的函数写到单个文件中，在使用其它函数时，直接调用此文件，而无需再次编写，这种调用文件的过程一般称为包含；程序猿希望代码更加灵活，所以通常会将被包含的文件设置为变量，用来进行动态调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分类：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地包含&lt;/li&gt;
&lt;li&gt;远程包含&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;任意文件上传&lt;/h2&gt;
&lt;p&gt;攻击者通过上传木马文件，获得webshell，危害等级超级高，现在的入侵中上传漏洞也是常见的漏洞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修复方案：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对文件格式限制，只允许某些格式的文件上传；&lt;/li&gt;
&lt;li&gt;对文件格式进行校验，前端跟服务器都要进行检验，（前端校验扩展名，后端校验扩展名、content-type等）&lt;/li&gt;
&lt;li&gt;将上传目录放置到工程目录之外，当作静态资源路径，对文件的权限进行设定，禁止文件下的执行权限。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;反序列化&lt;/h2&gt;
&lt;p&gt;把磁盘或网络节点上的字节序列恢复到对象的过程称为对象的反序列化，在java中比较常见，ObjectInputStream类的readObject()方法用于反序列化。&lt;/p&gt;
&lt;h2&gt;XML实体注入&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;XXE的危害&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读取任意文件&lt;/li&gt;
&lt;li&gt;执行系统命令，但需要有 expect 插件&lt;/li&gt;
&lt;li&gt;扫描网站的端口以及是否存在某些目录或文件&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 http 协议发起 SSRF 攻击
&lt;strong&gt;如何防御XXE攻击？&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用开发语言提供的禁用外部实体的方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;过滤用户提交的XML数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;漏洞防御&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;没有绝对安全系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;防护的三个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从源头上解决&lt;/li&gt;
&lt;li&gt;通过过滤代码&lt;/li&gt;
&lt;li&gt;第三方的防护&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;web漏洞是渗透测试的基础&lt;/h4&gt;
&lt;h4&gt;理解漏洞原理能帮助我们更好的挖掘漏洞&lt;/h4&gt;
&lt;h4&gt;攻防是一个整体&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;渗透测试的三种类型：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;黑盒渗透测试&lt;blockquote&gt;
&lt;p&gt;测试人员没有被提供更多他要渗透目标的信息，却有责任收集有关目标网络，系统或者应用程序的信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;白盒渗透测试&lt;blockquote&gt;
&lt;p&gt;测试人员将获得有关网络，系统或应用程序的完整信息以及源代码，操作系统详细信息和其他有关信息。可以认为是模拟内部来源的攻击。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;灰盒渗透测试&lt;blockquote&gt;
&lt;p&gt;测试人员将具有网络，系统或应用程序的部分信息。可以认为是外部黑客的攻击，黑客已经非法访问组织的网络基础设施文档。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;渗透测试执行标准（Penetration Testing Execution Standard：PTES）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;前期交互: 确定项目范围，周期，采用的技术手段和工具，以及其他约束条件&lt;/li&gt;
&lt;li&gt;信息收集: 收集目标相关资产信息，包括域名，IP，邮箱，防御措施等。&lt;/li&gt;
&lt;li&gt;威胁建模: 利用已经收集的信息对目标资产进行分析，获取其可能存在的威胁，并规划攻击路径。&lt;/li&gt;
&lt;li&gt;漏洞分析: 发现目标系统和应用中存在的漏洞&lt;/li&gt;
&lt;li&gt;漏洞利用: 对发现的漏洞使用攻击向量进行攻击&lt;/li&gt;
&lt;li&gt;后渗透: 建立立足点，进行持续维权以及内网渗透，获取指定的渗透目标数据、权限等。清理。&lt;/li&gt;
&lt;li&gt;报告: 输出渗透测试报告&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;渗透测试执行流程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;目标确认: 渗透约束条件和渗透最终目标&lt;/li&gt;
&lt;li&gt;信息收集: 收集目标范围内的各类信息&lt;/li&gt;
&lt;li&gt;漏洞发现: 在信息收集的基础上，发现目标应用系统的漏洞&lt;/li&gt;
&lt;li&gt;漏洞利用: 对发现的目标漏洞进行利用，通过漏洞利用获取目标系统权限&lt;/li&gt;
&lt;li&gt;权限维持，内网渗透: 进入目标系统，进行横向拓展，向渗透目标靠近&lt;/li&gt;
&lt;li&gt;目标获取，清理痕迹: 获取渗透目标权限或数据，回传数据，清理痕迹&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;渗透测试的本质是信息收集&lt;/h2&gt;
&lt;h2&gt;收集的信息越多，意味着攻击面越广&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;当渗透没有思路的时候，再重新回到信息收集       ---- Micropoor&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;四个维度的漏洞发现：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;传统漏洞&lt;/li&gt;
&lt;li&gt;利用通用漏洞&lt;/li&gt;
&lt;li&gt;弱口令等目标脆弱点&lt;/li&gt;
&lt;li&gt;代码审计&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;UDF提权&lt;/h2&gt;
&lt;p&gt;Userdefined function 用户自定义函数，Mysql为用户提供的一个扩展功能的接口。用户可以通过编写代码的方式编译成.so .dll文件，使用自定义的函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UDF提权的条件&lt;/strong&gt;
* 需要Mysql高于5.1的版本
* .so  .dll文件必须放在mysql的plugin目录下&lt;/p&gt;
&lt;h2&gt;redis提权&lt;/h2&gt;
&lt;p&gt;利用其服务端的程序的配置问题或漏洞来进行提权&lt;/p&gt;
&lt;h2&gt;获取shell&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;正向shell -&amp;gt; 客户端连接服务器端，客户端想要获取服务器端的shell&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反向shell -&amp;gt; 客户端连接服务器端，服务器端想要获得客户端的shell&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库提权：udf提权，mof提权&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;shell提权&lt;/li&gt;
&lt;li&gt;SQL注入获取shell&lt;/li&gt;
&lt;li&gt;XSS获取shell&lt;/li&gt;
&lt;li&gt;弱口令获取服务器权限&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;业务逻辑漏洞&lt;/h2&gt;
&lt;p&gt;由于程序逻辑不严谨或逻辑太复杂，导致一些逻辑分支不能正常处理或处理错误导致的漏洞。
与传统的漏洞相比，业务逻辑漏洞不易发现，挖掘思路不统一；不易防护，没有明确的防护方案
&lt;strong&gt;业务逻辑漏洞存在的可能场景：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户注册场景&lt;/li&gt;
&lt;li&gt;登录场景&lt;/li&gt;
&lt;li&gt;支付场景&lt;/li&gt;
&lt;li&gt;修改资料场景&lt;/li&gt;
&lt;li&gt;信息交互场景&lt;/li&gt;
&lt;li&gt;绑定手机场景&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;权限控制&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;越权：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平行越权访问漏洞，指的是权限平级的两个用户之间的越权访问；&lt;/li&gt;
&lt;li&gt;垂直越权访问漏洞，指的是权限不等的两个用户之间的越权访问。&lt;/li&gt;
&lt;li&gt;接口控制：特殊接口，没有做访问权限的控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;什么是接口控制？&lt;/strong&gt;&lt;/p&gt;
&lt;h5&gt;在博客论坛中，一个正常的普通用户A使用官方提供的API接口构造链接，用户B通过点击该链接后进行发送或转发用户A指定的内容。&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;平行越权漏洞的防护：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加访问与操作对象的用户属性，在对目标对象进行访问与操作时，服务端检验会话与对象的用户属性，在校验通过后才能执行读取和操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;垂直越权漏洞的防护：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有访问采用默认拒绝机制，采取基于角色访问控制，对于各个功能的访问，规定不同角色拥有不同的访问权限，当用户在使用该功能时，系统要校对用户的权限与访问控制机制是否与规定相同，通过校验者才能使用，否则拒绝使用该功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;传统的漏洞可以从哪三个方面进行防护？&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;从源头上解决，防止漏洞的产生；&lt;/li&gt;
&lt;li&gt;通过代码过滤，&lt;/li&gt;
&lt;li&gt;通过第三方服务介入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;让事物以迥于初衷的方式运作&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;漏洞复现&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;漏洞复现是对某一漏洞进行还原验证的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;漏洞复现的意义？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一，可以认识到相关的系统知识，比如命令行、系统配置文件等等；&lt;/li&gt;
&lt;li&gt;第二，对漏洞复现的认知，这个漏洞是如何产生的，是哪里的代码逻辑出现了问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;漏洞复现的三个步骤：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;搭建环境-》实现漏洞-》原理解析&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;通用漏洞&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;企业及互联网中常用的操作系统，系统组件，重要的框架以及应用中的安全漏洞。
通用漏洞是渗透测试流程中漏洞发现部分关注的漏洞方向之一，是学习漏洞挖掘知识的重要来源。&lt;/li&gt;
&lt;li&gt;PoC指一段漏洞证明的代码&lt;/li&gt;
&lt;li&gt;通用漏洞在渗透测试过程中占有很重要的分量，通过学习通用漏洞，既可以丰富个人的攻击宽度，也可以学习相关漏洞知识和挖掘漏洞的思路。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码审计原理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;代码审计是一种以发现程序错误，安全漏洞和违反程序规范为目标的源代码分析。&lt;/li&gt;
&lt;li&gt;代码审计是漏洞挖掘的重要途径。&lt;/li&gt;
&lt;li&gt;代码审计还是企业安全建设SDL流程中的一个环节。&lt;/li&gt;
&lt;li&gt;代码审计（白盒），能够覆盖更全面的安全问题。&lt;/li&gt;
&lt;li&gt;与黑盒测试相比，当有源代码时（代码审计）在寻找代码入口和程序执行路径等漏洞挖掘点时所做的猜测性工作会大大减少。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码审计的技能要求：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对编程的掌握（能看懂代码的逻辑）&lt;/li&gt;
&lt;li&gt;对漏洞形成原理的理解&lt;/li&gt;
&lt;li&gt;系统，中间件，框架等的熟悉程度&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码审计思路：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;关键词搜索：依赖漏洞关联的函数，搜索函数名称并追踪输入&lt;/li&gt;
&lt;li&gt;框架类基于功能审计：MVC框架功能和代码路由关系，直接定位业务逻辑代码&lt;/li&gt;
&lt;li&gt;通读代码：研究其代码构建逻辑&lt;/li&gt;
&lt;li&gt;敏感函数回溯&lt;/li&gt;
&lt;li&gt;通读全文&lt;/li&gt;
&lt;li&gt;功能点定向审计&lt;/li&gt;
&lt;/ul&gt;</content><category term="Web"></category><category term="WebSec"></category><category term="PWN"></category></entry><entry><title>XSS攻击</title><link href="https://leelongcrazy.github.io/xssgong-ji.html" rel="alternate"></link><published>2021-03-14T18:00:00+08:00</published><updated>2021-03-14T18:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2021-03-14:/xssgong-ji.html</id><summary type="html">&lt;p&gt;XSS攻击实战&lt;/p&gt;</summary><content type="html">&lt;h1&gt;XSS攻击&lt;/h1&gt;
&lt;h3&gt;反射型XSS&lt;/h3&gt;
&lt;p&gt;请求代码出现在URL中，作为输入提交到服务器，服务器解析后响应，响应内容中出现这段XSS代码，最后在浏览器解析执行，达到攻击效果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 常用攻击payload&lt;/span&gt;
&lt;span class="s1"&gt;&amp;#39; onclick=alert(1)//&lt;/span&gt;
&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;/script&amp;gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;//&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;存储型XSS&lt;/h3&gt;
&lt;h3&gt;DOM型XSS&lt;/h3&gt;</content><category term="Web"></category><category term="WebSec"></category><category term="PWN"></category></entry><entry><title>MFC框架笔记</title><link href="https://leelongcrazy.github.io/mfckuang-jia-bi-ji.html" rel="alternate"></link><published>2021-03-02T17:00:00+08:00</published><updated>2021-03-02T17:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2021-03-02:/mfckuang-jia-bi-ji.html</id><summary type="html">&lt;p&gt;MFC框架学习笔记&lt;/p&gt;</summary><content type="html">&lt;h1&gt;学习MFC前技术基础&lt;/h1&gt;
&lt;h2&gt;WIN32程序概念：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;message based: 文档基础&lt;/li&gt;
&lt;li&gt;event driven: 事件驱动&lt;/li&gt;
&lt;li&gt;multitasking: 多任务&lt;/li&gt;
&lt;li&gt;multithreading:多线程&lt;/li&gt;
&lt;li&gt;console programing:&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;C++基础：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类和对象&lt;/li&gt;
&lt;li&gt;this指针和继承&lt;/li&gt;
&lt;li&gt;静态成员&lt;/li&gt;
&lt;li&gt;虚函数与多态&lt;/li&gt;
&lt;li&gt;模板（template）类&lt;/li&gt;
&lt;li&gt;异常处理（exception handling）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;MFC重点：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CWinApp类：&lt;/li&gt;
&lt;li&gt;CFrameWnd类：&lt;/li&gt;
&lt;li&gt;CPaintDC类&lt;/li&gt;
&lt;li&gt;消息映射机制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;框架 MFC简介&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;微软基础类库（Microsoft Foundation Class），是微软公司提供的一个类库，以c++类的形式封装了win32 API，并且包含了一个应用程序框架。所以，MFC其实一个库和框架的混合体。&lt;/li&gt;
&lt;li&gt;库包含了类、对象和方法等已供程序员直接使用，而Framework则包含了更多的东西，如多种不同的库，资源等。并且库和框架之间还有一个调用上的不同 &lt;a href="https://martinfowler.com/bliki/InversionOfControl.html"&gt;详细&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;桌面程序需要实现的两大功能&lt;/li&gt;
&lt;li&gt;窗口创建&lt;/li&gt;
&lt;li&gt;消息处理&lt;/li&gt;
&lt;li&gt;MFC完成功能实现的基本流程&lt;/li&gt;
&lt;li&gt;设计窗口类&lt;/li&gt;
&lt;li&gt;注册窗口类&lt;/li&gt;
&lt;li&gt;创建窗口&lt;/li&gt;
&lt;li&gt;显示和更新窗口&lt;/li&gt;
&lt;li&gt;消息获取&lt;/li&gt;
&lt;li&gt;消息处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;MFC&lt;/h1&gt;
&lt;h2&gt;基础：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;UINT类型是由unsigned int类型派生出来的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;字符串与数值类型之间的转换&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;    &lt;span class="c1"&gt;//字符串变为数字.通用版.&lt;/span&gt;
    &lt;span class="n"&gt;nNum1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_ttoi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ch1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  

    &lt;span class="c1"&gt;//数字转为字符串.设置到编辑框三种.&lt;/span&gt;
    &lt;span class="n"&gt;_itot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nNum3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ch3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//十进制转换.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;afx_msg&lt;/h2&gt;
&lt;p&gt;是应用框架产生的消息映射函数。&lt;/p&gt;
&lt;p&gt;afx_msg为消息标志，向系统声明：有消息映射到函数实现体；而在map宏定义中，就有具体消息和此函数的映射定义。&lt;/p&gt;
&lt;p&gt;在类头中增加消息声明；在类实现文件中增加消息定义和执行函数。&lt;/p&gt;
&lt;p&gt;&lt;img alt="messages" src="./images/wm_messages.png"&gt;&lt;/p&gt;
&lt;h2&gt;文档/视图体系结构&lt;/h2&gt;
&lt;p&gt;依靠文档保存应用程序的数据，依靠视图对象控制视图中显示的数据。&lt;/p&gt;
&lt;h2&gt;视图：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用户视角，视图就是一个普通的窗口&lt;/li&gt;
&lt;li&gt;程序员的视角，视图是一个个C++ 对象，派生自MFC中CView类&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;消息映射&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="content/images/message_map.png"&gt;&lt;/p&gt;
&lt;h2&gt;资源编辑器（.rc）&lt;/h2&gt;
&lt;h2&gt;MFC基础：&lt;/h2&gt;
&lt;h3&gt;画图：CPaintDC类响应WM_PAINT消息，允许你在窗口客户区画图。&lt;/h3&gt;
&lt;h3&gt;鼠标和键盘：&lt;/h3&gt;
&lt;h4&gt;客户区鼠标消息&lt;/h4&gt;
&lt;p&gt;&lt;img alt="mouse_message" src="./images/mouse_message.png"&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;afx_msg&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;OnMsgName&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UINT&lt;/span&gt; &lt;span class="n"&gt;nFlags&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CPoint&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;// point 指出光标的位置； nFlags指出消息产生时鼠标键以及shift键和Ctrl键的状态&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="nflags" src="./images/nflags.png"&gt;&lt;/p&gt;
&lt;h5&gt;从键盘获取输入&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;输入焦点的概念：&lt;/li&gt;
&lt;li&gt;获取击键码：&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;菜单&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建菜单：在资源描述文件（.rc）中添加&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加载并显示菜单：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;c++
    CMainWindow::CMainWindow()
    {
        Create(NULL, _T("The Hello Application"), WS_OVERLAPPEDWINDOW | WS_VSCROLL | WS_HSCROLL | WS_SYSMENU | WS_CAPTION,
            CRect(400, 100, 1200, 1000), NULL, MAKEINTRESOURCE(IDR_MAINFRAME));
    }&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MAKEINTRESOURCE(IDR_MAINFRAME)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;MFC集合类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;li&gt;列表&lt;/li&gt;
&lt;li&gt;映射表：设计映射表的目的是给定一个关键字，可以很快在表中找到响应的项目，通常只查找一次。&lt;/li&gt;
&lt;li&gt;类型指针类&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;文件的I/O及序列化&lt;/h2&gt;
&lt;h2&gt;控件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;传统控件：6个预定义的WNDCLASS&lt;/li&gt;
&lt;li&gt;&lt;img alt="" src="./images/winclass.png"&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;对话框&lt;/h2&gt;
&lt;p&gt;创建对话框的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建对话框资源：创建新的对话框模板、设置对话框属性和为对话框添加各种控件&lt;/li&gt;
&lt;li&gt;生成对话框类：新建对话框类、添加控件变量和控件的消息处理函数等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在资源视图页面：Ctrl+D可以更改tab顺序数字，按ESC键退出&lt;/p&gt;
&lt;p&gt;对话框分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模态对话框：当它弹出后，本应用程序其他窗口将不再接受用户输入，只有该对话框响应用户输入，在对它进行相应操作退出后，其他窗口才能继续与用户交互&lt;/li&gt;
&lt;li&gt;非模态对话框：它弹出后，本程序其他窗口仍能响应用户输入。非模态对话框一般用来显示提示信息等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;关闭对话框的方式：&lt;/h4&gt;
&lt;p&gt;``` C ++
// 退出程序
    AfxGetMainWnd-&amp;gt;SendMessage(WM_CLOSE);
// 关闭当前窗口
    DestoryWindow();
// 关闭模式对话框
    EndDialog(0);&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;对话框：消息对话框&lt;/span&gt;

&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;CWnd&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;MessageBox&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;CWnd&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;AfxMessageBox&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="err"&gt;用例：&lt;/span&gt;

&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="o"&gt;```&lt;/span&gt; &lt;span class="k"&gt;C&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;
   &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MessageBox&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_T&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;您确定要进行乘法计算吗？&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;_T&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;乘法计算器&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;MB_OKCANCEL&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;MB_ICONQUESTION&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AfxMessageBox&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_T&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;您确定要进行乘法计算吗？&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;MB_OKCANCEL&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;MB_ICONASTERISK&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
   &lt;span class="o"&gt;```&lt;/span&gt;

&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; 

&lt;span class="o"&gt;##&lt;/span&gt; &lt;span class="err"&gt;编辑控制（&lt;/span&gt;&lt;span class="n"&gt;CEdit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="err"&gt;两种类别：&lt;/span&gt;&lt;span class="n"&gt;Control&lt;/span&gt; &lt;span class="err"&gt;和&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt;

&lt;span class="err"&gt;变量类型为：&lt;/span&gt;

&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;CEdit&lt;/span&gt;  
&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;CString&lt;/span&gt;

&lt;span class="o"&gt;```&lt;/span&gt; &lt;span class="k"&gt;C&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;CEdit&lt;/span&gt;
    &lt;span class="n"&gt;c_edit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetWindowText&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;获取变量值&lt;/span&gt; &lt;span class="n"&gt;CString类型&lt;/span&gt;
    &lt;span class="n"&gt;c_edit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetWindowText&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;设置变量值&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Cstring&lt;/span&gt;
    &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;直接对变量赋&lt;/span&gt; &lt;span class="n"&gt;CString类型&lt;/span&gt;
        &lt;span class="n"&gt;c_edit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;
        &lt;span class="n"&gt;SetDlgItemText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IDC_EDIT1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nb"&gt;Int&lt;/span&gt;
        &lt;span class="n"&gt;SetDlgItemInt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IDC_EDIT1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;组合框控件&lt;/h2&gt;
&lt;p&gt;CComboBox类&lt;/p&gt;
&lt;p&gt;主要成员函数：&lt;/p&gt;
&lt;p&gt;int GetCount( ) const;
       获取组合框控件的列表框中列表项的数量。&lt;/p&gt;
&lt;p&gt;int GetCurSel( ) const;
   获取组合框控件的列表框中选中项的索引，如果没有选中任何项，该函数返回CB_ERR。&lt;/p&gt;
&lt;p&gt;int SetCurSel(int nSelect);
   在组合框控件的列表框中选择某项。nSelect参数指定了要选择的列表项的索引，如果为-1则列表框中当前选择项被取消选中，编辑框也被清空。&lt;/p&gt;
&lt;p&gt;void GetLBText(int nIndex,CString&amp;amp; rString) const;
       从组合框控件的列表框中获取某项的字符串。nIndex参数指定要获取字符串的列表项的索引，CString参数用于接收取到的字符串。&lt;/p&gt;
&lt;p&gt;int GetLBTextLen(int nIndex) const;
       获取组合框控件的列表框中某项的字符串长度。nIndex参数指定要获取字符串长度的列表项的索引。  &lt;/p&gt;
&lt;p&gt;int AddString(LPCTSTR lpszString);
   为组合框控件中的列表框添加新的列表项。lpszString参数是指向要添加的字符串的指针。该函数的返回值如果大于等于0，那么它就是新列表项的索引，而如果有错误发生则会返回CB_ERR，如果没有足够的内存存放新字符串则返回CB_ERRSPACE。&lt;/p&gt;
&lt;p&gt;int DeleteString(UINT nIndex);
   删除组合框中某指定位置的列表项。nIndex参数指定了要删除的列表项的索引。该函数的返回值如果大于等于0，那么它就是组合框中剩余列表项的数量。如果nIndex指定的索引超出了列表项的数量则返回CB_ERR。&lt;/p&gt;
&lt;p&gt;int FindString(int nStartAfter,LPCTSTR lpszString) const;
   在组合框控件的列表框中查找但不选中第一个包含指定前缀的列表项。nStartAfter参数指定了第一个要查找的列表项之前的那个列表项的索引。lpszString指向包含要查找的前缀的字符串。该函数的返回值如果大于等于0，那么它是匹配列表项的索引，如果查找失败则返回CB_ERR。&lt;/p&gt;
&lt;p&gt;int InsertString(int nIndex,LPCTSTR lpszString);
   向组合框控件的列表框中插入一个列表项。nIndex参数指定了要插入列表项的位置，lpszString参数则指定了要插入的字符串。该函数返回字符串被插入的位置，如果有错误发生则会返回CB_ERR，如果没有足够的内存存放新字符串则返回CB_ERRSPACE。&lt;/p&gt;
&lt;p&gt;int SelectString(int nStartAfter,LPCTSTR lpszString);
   在组合框控件的列表框中查找一个字符串，如果查找到则选中它，并将其显示到编辑框中。参数同FindString。如果字符串被查找到则返回此列表项的索引，如果查找失败则返回CB_ERR，并且当前选择项不改变。&lt;/p&gt;
&lt;p&gt;使用步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在DlgClass::OnInitDialog()中初始化ComboBox内容；可指定默认第一选项；&lt;/li&gt;
&lt;li&gt;定义CBN_SELCHANGE消息的处理函数；获取组合框的选中索引，根据索引获取组合框中的对应值&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;滚动条控件&lt;/h2&gt;
&lt;p&gt;CSrollBar类&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 滚动条条拖动状态&lt;/span&gt;
&lt;span class="n"&gt;SB_LINEUP&lt;/span&gt;           &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;SB_LINELEFT&lt;/span&gt;         &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;SB_LINEDOWN&lt;/span&gt;         &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;SB_LINERIGHT&lt;/span&gt;        &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;SB_PAGEUP&lt;/span&gt;           &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="n"&gt;SB_PAGELEFT&lt;/span&gt;         &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="n"&gt;SB_PAGEDOWN&lt;/span&gt;         &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="n"&gt;SB_PAGERIGHT&lt;/span&gt;        &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="n"&gt;SB_THUMBPOSITION&lt;/span&gt;    &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="n"&gt;SB_THUMBTRACK&lt;/span&gt;       &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="n"&gt;SB_TOP&lt;/span&gt;              &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;SB_LEFT&lt;/span&gt;             &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;SB_BOTTOM&lt;/span&gt;           &lt;span class="mi"&gt;7&lt;/span&gt;
&lt;span class="n"&gt;SB_RIGHT&lt;/span&gt;            &lt;span class="mi"&gt;7&lt;/span&gt;
&lt;span class="n"&gt;SB_ENDSCROLL&lt;/span&gt;        &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;列表视图控件&lt;/h2&gt;
&lt;p&gt;CListCtrl类内部的成员函数：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UINT GetSelectedCount( ) const;&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;该函数返回列表视图控件中被选择列表项的数量。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;POSITION GetFirstSelectedItemPosition( ) const;&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;获取列表视图控件中第一个被选择项的位置。返回的POSITION值可以用来迭代来获取其他选择项，可以当作参数传入下面的GetNextSelectedItem函数来获得选择项的索引。如果没有被选择项则返回NULL。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;int GetNextSelectedItem(POSITION&amp;amp; pos) const;&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;该函数获取由pos指定的列表项的索引，然后将pos设置为下一个位置的POSITION值。参数pos为之前调用GetNextSelectedItem或GetFirstSelectedItemPosition得到的POSITION值的引用。返回值就是pos指定列表项的索引。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;int GetItemCount( ) const;&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;获取列表视图控件中列表项的数量。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;int InsertColumn(int nCol,const LVCOLUMN* pColumn );&lt;/strong&gt;
&lt;strong&gt;int InsertColumn(int nCol,LPCTSTR lpszColumnHeading,int nFormat = LVCFMT_LEFT,int nWidth = -1,int nSubItem = -1 );&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;这两个函数用于在报表式列表视图控件中插入列。第一个函数中，nCol参数为插入列的索引，pColumn参数指向LVCOLUMN结构，其中包含了插入列的属性。第二个函数中，nCol参数也是插入列的索引，lpszColumnHeading参数为列标题字符串，nFormat参数为列中文本的对齐方式，可以是LVCFMT_LEFT、LVCFMT_RIGHT或LVCFMT_CENTER，nWidth参数为列宽，nSubItem为插入列对应列表子项的索引。两个函数在成功时都返回新列的索引，失败都返回-1。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;BOOL DeleteColumn(int nCol);&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;   该函数用于删除列表视图控件中的某列。参数nCol为删除列的索引。删除成功则返回TRUE，失败返回FALSE。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;int InsertItem(int nItem,LPCTSTR lpszItem);&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;向列表视图控件中插入新的列表项。参数nItem为要插入项的索引，参数lpszItem为要插入项的标签字符串。如果插入成功则返回新列表项的索引，否则返回-1。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;BOOL DeleteItem(int nItem);&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从列表视图控件中删除某个列表项。参数nItem指定了要删除的列表项的索引。删除成功则返回TRUE，否则返回FALSE。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;CString GetItemText(int nItem,int nSubItem) const;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;获取指定列表项或列表子项的显示文本。参数nItem指定了列表项的索引，参数nSubItem指定了列表子项的索引。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;BOOL SetItemText(int nItem,int nSubItem,LPCTSTR lpszText);&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设置指定列表项或列表子项的显示文本。参数nItem和nSubItem同GetItemText。参数lpszText为要设置的显示文本字符串。如果设置成功则返回TRUE，否则返回FALSE。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;DWORD_PTR GetItemData(int nItem) const;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该函数用于获取指定列表项的附加32位数据。参数nItem为列表项的索引。返回值就是由nItem指定列表项的附加32位数据。   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;BOOL SetItemData(int nItem,DWORD_PTR dwData);&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该函数用于为指定列表项设置附加32位是数据。参数nItem为列表项的索引，参数dwData为列表项的附加32位数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ListCtrlBox&lt;/p&gt;
&lt;p&gt;View属性有4种风格：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;icon：图标风格&lt;/li&gt;
&lt;li&gt;Small icon：小图标风格&lt;/li&gt;
&lt;li&gt;List：列表风格&lt;/li&gt;
&lt;li&gt;Report：报表风格（表格视图）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CListCtrl::SetExtendedStyle&lt;/p&gt;
&lt;p&gt;列表视图控件用法：&lt;/p&gt;
&lt;p&gt;``` C ++
m_ProgramList.SetExtendedStyle(m_ProgramList.GetExtendedStyle() | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_CHECKBOXES);&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt;列表视图控件的风格类型:&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;LVS_EX_GRIDLINES //绘制表格,网格线。
　　LVS_EX_SUBITEMIMAGES//子项目图标列表
　　LVS_EX_CHECKBOXES //带复选框
　　LVS_EX_TRACKSELECT //自动换行
　　LVS_EX_HEADERDRAGDROP//报表头可以拖拽
　　LVS_EX_FULLROWSELECT //选择整行，允许选择整行。
   LVS_EX_ONECLICKACTIVATE//单击激活单击选中项目。
　　LVS_EX_TWOCLICKACTIVATE//双击激活
　　LVS_EX_FLATSB//扁平滚动条
　　LVS_EX_REGIONAL
　　LVS_EX_INFOTIP
　　LVS_EX_UNDERLINEHOT
　　LVS_EX_UNDERLINECOLD
　　LVS_EX_MULTIWORKAREAS//多工作区
```&lt;/p&gt;
&lt;h1&gt;相关资料：&lt;/h1&gt;
&lt;p&gt;网站：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jizhuomi.com/software/257.html"&gt;鸡啄米--VS2010/MFC编程入门教程之目录和总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;书籍：&lt;/p&gt;
&lt;p&gt;《基于visual C++ MFC编程》&lt;/p&gt;
&lt;p&gt;《MFC Windows程序设计 第2版》&lt;/p&gt;</content><category term="CPP"></category><category term="MFC"></category><category term="Programe"></category></entry><entry><title>C++笔记</title><link href="https://leelongcrazy.github.io/cbi-ji.html" rel="alternate"></link><published>2021-02-28T17:00:00+08:00</published><updated>2021-02-28T17:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2021-02-28:/cbi-ji.html</id><summary type="html">&lt;p&gt;C++学习笔记&lt;/p&gt;</summary><content type="html">&lt;h1&gt;神奇的用法：&lt;/h1&gt;
&lt;h3&gt;#pragma&lt;/h3&gt;
&lt;p&gt;在所有的预处理指令中，#pragma 指令可能是最复杂的了，它的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。#pragma指令对每个编译器给出了一个方法，在保持与C和C++语言完全兼容的情况下，给出主机或操作系统专有的特征。依据定义，编译指示是机器或操作系统专有的，且对于每个编译器都是不同的。   #pragma once   只要在头文件的最开始加入这条指令就能够保证头文件被编译一次&lt;/p&gt;
&lt;h1&gt;ifndef，#define，#endif这个是C++语言相关，这是C++语言中的宏定义，通过宏定义避免文件多次编译。所以在所有支持C++语言的编译器上都是有效的，如果写的程序要跨平台，最好使用这种方式（被称为预处理指令）&lt;/h1&gt;
&lt;h1&gt;pragma comment&lt;/h1&gt;
&lt;p&gt;该指令将一个注释记录放入一个对象文件或可执行文件中。
常用的lib关键字，可以帮我们连入一个库文件。&lt;/p&gt;
&lt;h1&gt;C++基础&lt;/h1&gt;
&lt;h2&gt;一些概念：&lt;/h2&gt;
&lt;h4&gt;指针&lt;/h4&gt;
&lt;p&gt;指针的值（即地址）应属于下列4种状态之一：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;指向一个对象&lt;/li&gt;
&lt;li&gt;指向紧邻对象所占空间的下一个位置；&lt;/li&gt;
&lt;li&gt;空指针，意味着指针没有指向任何对象&lt;/li&gt;
&lt;li&gt;无效指针，上述情况之外的其他值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;标准异常&lt;/h3&gt;
&lt;p&gt;&lt;img alt="error" src="./images/errors.png"&gt;&lt;/p&gt;
&lt;h2&gt;数据类型&lt;/h2&gt;
&lt;h3&gt;向量Vector: 向量是一个具有相同类型对象的集合。与数组相比，在初定义时可以不指定大小。&lt;/h3&gt;
&lt;h2&gt;C++ 中的一些关键字&lt;/h2&gt;
&lt;h3&gt;const&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;修饰变量，变量不可以被修改；&lt;/li&gt;
&lt;li&gt;修饰指针，分为指向常量的指针和自身是常量的指针（常量指针）&lt;/li&gt;
&lt;li&gt;修饰引用，指向常量的引用，用于形参类型，避免拷贝，又避免楼函数对值的修改；&lt;/li&gt;
&lt;li&gt;修饰成员函数，说明该成员函数内不能修改成员的变量&lt;/li&gt;
&lt;/ol&gt;
&lt;h6&gt;conset的指针和引用&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;指针&lt;/li&gt;
&lt;li&gt;指向常量的指针&lt;/li&gt;
&lt;li&gt;自身是常量指针（常量指针）&lt;/li&gt;
&lt;li&gt;引用&lt;/li&gt;
&lt;li&gt;指向常量的引用&lt;/li&gt;
&lt;li&gt;没有 const reference ，因为引用本身就是const pointer&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;被 const 修饰（在 const 后面）的值不可改变&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;static&lt;/h3&gt;
&lt;p&gt;作用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修饰普通变量，修改变量的存储区域和声明周期，使变量存储在静态区，在main函数运行前就分配楼空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。&lt;/li&gt;
&lt;li&gt;修饰普通函数， 表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。&lt;/li&gt;
&lt;li&gt;修饰成员变量， 修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。&lt;/li&gt;
&lt;li&gt;修饰成员函数， 修饰成员函数使得不需要生成对象就可以访问该函数，但是在static函数内不能访问非静态成员。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;this指针&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;this指针&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;inline 内联函数&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;相当于把内联函数里面的内容写在调用内联函数处；&lt;/li&gt;
&lt;li&gt;相当于不用执行进入函数的步骤，直接执行函数体；&lt;/li&gt;
&lt;li&gt;相当于宏，比宏多了类型检查，真正具有函数特性；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;virtual 虚函数&lt;/h3&gt;
&lt;h4&gt;虚函数（virtual）可以是内联函数（inline）吗？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候，不能内联。&lt;/li&gt;
&lt;li&gt;内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;volatile&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;volatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统，硬件，其他线程等）更改。所以使用volatile告诉编译器不应对这样的对象进行优化。&lt;/li&gt;
&lt;li&gt;volatile声明的变量，每次访问时都必须从内存中取出值（没有被volatile修饰的变量，可能由于编译器的优化，从CPU寄存器中取值）&lt;/li&gt;
&lt;li&gt;指针可以是 volatile&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;assert（）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;断言，是宏，而非函数。&lt;/li&gt;
&lt;li&gt;assert 宏的原型定义在 &lt;strong&gt;&lt;assert.h&gt;&lt;/strong&gt;（C）、&lt;strong&gt;&lt;cassert&gt;&lt;/strong&gt;（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 &lt;strong&gt;NDEBUG&lt;/strong&gt; 来关闭assert， 但是需要在源代码开头， &lt;strong&gt;include &lt;assert.h&gt;&lt;/strong&gt; 之前。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;sizeof()&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;获得对象所占空间大小&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;auto&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;auto可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型，类似的关键字还有decltype&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;goto&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;goto 的标志符号后面的字符为&lt;strong&gt;分号 (:)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;#pragma pack(n)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;设定结构体、联合以及类成员变量以n字节方式对齐&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;memset()&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以对数组中的每一个元素赋同样的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;C++
  int a[5] = {1,2,3,4,5};
  memset(a, 0, sizeof(a)); // a = {0, 0, 0, 0, 0}
  memset(a, -1, sizeof(a)); // a = {-1, -1, -1, -1, -1}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;extern "C"&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;被extern限定的函数或变量是extern 类型的&lt;/li&gt;
&lt;li&gt;被&lt;strong&gt;extern "C"&lt;/strong&gt;修饰的变量和函数是按照C语言的方式编译和链接的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;extern "C"&lt;/strong&gt; 的作用是让C++ 编译器将  extern "C" 声明的代码当做 C 语言代码处理，可以避免C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;struct 和 typedef struct&lt;/h3&gt;
&lt;h4&gt;C 中&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// C&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Student&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// 等价于&lt;/span&gt;
&lt;span class="c1"&gt;// C&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Student&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Student&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// 此时的 S 等价于 struct Student ,但是两个标识符名称空间不相同。另外还可以定义与 struct Student 不冲突的 void Student(){}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;C ++ 中&lt;/h4&gt;
&lt;h6&gt;由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。&lt;/h6&gt;
&lt;ol&gt;
&lt;li&gt;如果在类标识符空间定义了 struct Student{...}; ,使用 Student me; 时，编译器将搜索全局标识符表， Student 未找到，则在类标识符内搜索。即表现为可以使用 Student 也可以使用 struct Student , 如下&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;``` C++
   // cpp
   struct Student
   {
       int age;
   };&lt;/p&gt;
&lt;p&gt;void f( Student me); // "struct" 关键字可以省略
   ```&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若定义了 与 Student 同名函数后， 则 Student 只代表函数， 不代表结构体，如下&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;C++
   typedef struct Student
   {
       int age;
   }S;
   void Student(){} // 定义后，Student 只代表此函数
   // void S(){} // 错误， 符号 “S”已经被定义为一个 “struct Student” 的别名
   int main()
   {
       Student();
       struct Student me; // ==&amp;gt; 或者 “S me”
       return 0;
   }&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;C ++ 中的 struct 和 class&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;struct更适合看成一个数据结构的实现体，class更适合看成是一个对象的实现体&lt;/li&gt;
&lt;li&gt;区别：&lt;/li&gt;
&lt;li&gt;最本质的区别就是默认的访问控制&lt;ul&gt;
&lt;li&gt;默认的继承访问权限。struct 是public的， class是private的。&lt;/li&gt;
&lt;li&gt;struct 作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;union联合&lt;/h3&gt;
&lt;h3&gt;explicit （显式）关键字&lt;/h3&gt;
&lt;h3&gt;using&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;using 声明 : &lt;strong&gt;using namespace_name::name;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;using 指示 : &lt;strong&gt;using namespace_name name;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;尽量少使用 using指示（减少污染命名空间），应该多使用 using 声明，&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;::&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;分类&lt;/li&gt;
&lt;li&gt;全局作用域符（::name）&lt;/li&gt;
&lt;li&gt;类作用域符（class::name）&lt;/li&gt;
&lt;li&gt;命名空间作用域符（namespace::name）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;enum 枚举类型&lt;/h3&gt;
&lt;p&gt;``` C ++ 
// 限定作用域的枚举类型
enum class open_modes { input, output, append };&lt;/p&gt;
&lt;p&gt;// 不限定作用域的枚举类型
enum color { red yellow, green };
enum { floatPrec=6, doublePrec=10 };
```&lt;/p&gt;
&lt;h3&gt;decltype&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;该关键字用于检查实体的声明类型或表达式的类型及值分类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;引用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;左值引用：常规引用，一般表示对象的身份&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;右值引用：右值引用必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;右值引用可实现转移语义和精确传递，它的主要目的有两个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;能够更简洁明确地定义泛型函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用折叠&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;引用即别名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;宏&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;宏定义可以实现类似于函数的功能，但是他终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对“参数”进行的是一对一的替换。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;成员初始化列表&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;好处：&lt;/li&gt;
&lt;li&gt;更高效&lt;/li&gt;
&lt;li&gt;有些场合必须要用初始化列表&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;面向对象&lt;/h3&gt;
&lt;h5&gt;面向对象程序设计是种具有对象概念的程序编程典范，同是也是一种程序开发的抽象方针。&lt;/h5&gt;
&lt;h5&gt;面向对象的三大特征：封装、继承、多态。&lt;/h5&gt;
&lt;p&gt;&lt;img alt="面向对象基本特征" src="面向对象基本特征.png"&gt;&lt;/p&gt;
&lt;h2&gt;封装&lt;/h2&gt;
&lt;h5&gt;把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的信息隐藏。&lt;/h5&gt;
&lt;h5&gt;关键字：public, protected, private。不写默认为 private。&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;public: 可以被任意实体访问&lt;/li&gt;
&lt;li&gt;protected: 只允许被子类及本类的成员函数访问&lt;/li&gt;
&lt;li&gt;private: 只允许被本类的成员函数、友元类或友元函数访问&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;继承&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基类（父类）---&amp;gt; 派生类（子类）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;多态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;多态，多种状态&lt;/li&gt;
&lt;li&gt;多态是以封装和继承为基础的&lt;/li&gt;
&lt;li&gt;C++ 多态分类及实现：&lt;ol&gt;
&lt;li&gt;重载多态：函数重载，运算符重载&lt;/li&gt;
&lt;li&gt;子类型多态：虚函数&lt;/li&gt;
&lt;li&gt;参数多态性：类模板，函数模板&lt;/li&gt;
&lt;li&gt;强制多态：基本类型转换，自定义类型转换&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;静态多态--》函数重载&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一个名字可以定义多个函数，只要这些函数的形参数量或形参类型不同就行。根据调用时所使用的实参，编译器可以自动的选择被调用的函数。&lt;strong&gt;选取最佳函数的过程被称为函数匹配&lt;/strong&gt;（best match）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;动态多态--》虚函数&lt;/p&gt;
&lt;h2&gt;C++ 类&amp;amp;对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类的基本思想是&lt;strong&gt;数据抽象&lt;/strong&gt;和&lt;strong&gt;封装&lt;/strong&gt;。数据抽象是一种依赖&lt;strong&gt;接口&lt;/strong&gt;和&lt;strong&gt;实现&lt;/strong&gt;分离的编程设计技术。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类的两项基本能力：1是数据抽象，即定义数据成员和函数成员的能力，二是封装，即保护类的成员不能被随意访问的能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以关键字class开头&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;定义了类的对象包括什么，以及可以在这个对象上执行哪些操作（即成员变量，成员函数）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;访问数据成员&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类对象的公共（public）数据成员可以使用直接成员访问运算符（.）来访问。&lt;/li&gt;
&lt;li&gt;私有的成员和受保护的成员不能使用直接成员访问运算符（.）来直接访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;类相关概念：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类成员函数：把定义和原型写在类定义内部的函数，就像类中的其他变量。&lt;/li&gt;
&lt;li&gt;类访问修饰符：类成员可以被定义为public、private、protected。默认情况下为private。&lt;/li&gt;
&lt;li&gt;构造函数&amp;amp;析构函数： 创建类要提供一种或几种&lt;em&gt;成员函数来控制其对象初始化的过程&lt;/em&gt;，这种特殊的成员函数就是 &lt;em&gt;构造函数&lt;/em&gt; 。构造函数在创建新对象时调用，析构函数在删除所创建对象时调用。&lt;/li&gt;
&lt;li&gt;构造函数的定义：&lt;/li&gt;
&lt;li&gt;构造函数的名字和类名字相同&lt;/li&gt;
&lt;li&gt;没有返回值&lt;/li&gt;
&lt;li&gt;不能声明为const&lt;/li&gt;
&lt;li&gt;C++拷贝构造函数：是一种特殊的构造函数，在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;友元类：在A类中声明B类是它的朋友，B类中定义A类的对象，那么在B类中通过该对象可以实现对A类私有数据的访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C++友元函数：可以在类的外部通过对象使用类的私有数据成员。可以访问private和protected成员。&lt;em&gt;一般来说，最好在类定义开始或者结束前的位置中集中声明友元&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;C++ 内联函数&lt;/li&gt;
&lt;li&gt;C++中的this指针：每个对象都有一个特殊的指针this，指向对象本身。&lt;/li&gt;
&lt;li&gt;C++中指向类的指针：如同指向结构的指针。实际上类可以看成是一个带有函数的结构。&lt;/li&gt;
&lt;li&gt;C++类的静态成员：类的数据成员和函数成员都可以被声明为静态的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="friend_class" src=".\images\friend_class.png"&gt;&lt;/p&gt;
&lt;h4&gt;函数的返回值类型是类的引用类型，在成员函数内部可以直接使用类的数据成员。&lt;/h4&gt;
&lt;h2&gt;C++ 模板&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模板是编写泛型类或函数的蓝图或公式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数模板：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模板函数的定义一般形式：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;c++
    template &amp;lt;typename type&amp;gt; ret-type func-name(parameter list)
    {
        // 函数主体
    }&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类模板：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类模板的一般定义形式：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;C++
    template &amp;lt;class type&amp;gt; class class-name
    {
        // 代码
    }&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;C++ STL（标准模板库）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++ 标准模板库的核心包括以下三个组件：容器，算法，迭代器。&lt;/li&gt;
&lt;li&gt;容器：用来管理某一类对象的集合，例如deque、list、vector、map等。&lt;/li&gt;
&lt;li&gt;算法：作用于容器。提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。&lt;/li&gt;
&lt;li&gt;迭代器：用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;C++ 标准库&lt;/h2&gt;
&lt;p&gt;C++标准库包含了所有的C标准库，为了支持安全类型安全，做了一定的添加和修改&lt;/p&gt;
&lt;p&gt;分为两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准函数库：由通用的、独立的、不属于任何类的函数组成。函数库继承自C语言。（以下是分类）&lt;/li&gt;
&lt;li&gt;输入/输出 I/O&lt;/li&gt;
&lt;li&gt;字符串和字符处理&lt;/li&gt;
&lt;li&gt;数学&lt;/li&gt;
&lt;li&gt;时间、日期和本地化&lt;/li&gt;
&lt;li&gt;动态分配&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;li&gt;宽字符函数&lt;/li&gt;
&lt;li&gt;面向对象类库：是类及其相关函数的集合。&lt;/li&gt;
&lt;li&gt;标准的C++ I/O类&lt;/li&gt;
&lt;li&gt;String类&lt;/li&gt;
&lt;li&gt;数值类&lt;/li&gt;
&lt;li&gt;STL容器类&lt;/li&gt;
&lt;li&gt;STL算法&lt;/li&gt;
&lt;li&gt;STL函数对象&lt;/li&gt;
&lt;li&gt;STL迭代器&lt;/li&gt;
&lt;li&gt;STL分配器&lt;/li&gt;
&lt;li&gt;本地化类&lt;/li&gt;
&lt;li&gt;异常处理类&lt;/li&gt;
&lt;li&gt;杂项支持类&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;宽字符版本的类型和函数以一个w开始。&lt;/h3&gt;
&lt;h2&gt;顺序容器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;顺序容器为程序员提供了控制元素存储和访问顺序的能力。&lt;/li&gt;
&lt;li&gt;提供了快速顺序访问元素的能力&lt;/li&gt;
&lt;li&gt;性能折中：&lt;/li&gt;
&lt;li&gt;向容器添加或从容器中删除元素的代价&lt;/li&gt;
&lt;li&gt;非顺序访问容器中元素的代价&lt;/li&gt;
&lt;li&gt;顺序容器类型：&lt;/li&gt;
&lt;li&gt;vector：&lt;/li&gt;
&lt;li&gt;deque:&lt;/li&gt;
&lt;li&gt;list:&lt;/li&gt;
&lt;li&gt;forward_list:&lt;/li&gt;
&lt;li&gt;array:&lt;/li&gt;
&lt;li&gt;string:&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;关联容器&lt;/h2&gt;
&lt;p&gt;关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。&lt;/p&gt;
&lt;p&gt;与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。&lt;/p&gt;
&lt;p&gt;类型分类：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;map：key-value&lt;/li&gt;
&lt;li&gt;set：关键字即值&lt;/li&gt;
&lt;li&gt;multimap: 关键字可以重复出现的map&lt;/li&gt;
&lt;li&gt;multiset: 关键字可以重复出现的set&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;无序关联容器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;unordered_map&lt;/li&gt;
&lt;li&gt;unordered_set&lt;/li&gt;
&lt;li&gt;unordered_multimap&lt;/li&gt;
&lt;li&gt;unordered_multiset&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;容器操作-》类型别名 -&amp;gt; const_iterator：可以读取元素，但不能修改元素的迭代器类型。&lt;/h3&gt;
&lt;h2&gt;获取迭代器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;c.begin(), c.end() : 返回指向c的首元素和尾元素之后位置的迭代器&lt;/li&gt;
&lt;li&gt;c.cbegin(), c.cend() :返回 const_iterator&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;C++ 4种编程风格：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C风格&lt;/li&gt;
&lt;li&gt;基于对象&lt;/li&gt;
&lt;li&gt;面向对象&lt;/li&gt;
&lt;li&gt;泛型&lt;/li&gt;
&lt;li&gt;“基于组件”的风格&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;动态内存与智能指针：&lt;/h2&gt;
&lt;h1&gt;C语言&lt;/h1&gt;
&lt;p&gt;自由的代价永远是警惕。&lt;/p&gt;
&lt;h1&gt;基础十问&lt;/h1&gt;
&lt;p&gt;1、C与C++的关系是什么？&lt;/p&gt;
&lt;p&gt;C是C++ 的一部分，C++是C的超集。&lt;/p&gt;
&lt;p&gt;2、面向对象与C++的关系是什么？&lt;/p&gt;
&lt;p&gt;3、面向对象的方法与面向对象编程的关系是什么？&lt;/p&gt;
&lt;p&gt;4、面向对象编程的优势（优点、特性）是什么？&lt;/p&gt;
&lt;p&gt;5、什么是对象，什么是类，它们的关系如何？&lt;/p&gt;
&lt;p&gt;6、类的定义、初始化、赋值、构造和析构的具体操作方法。成员、方法、const 和this指针。&lt;/p&gt;
&lt;p&gt;7、重载与类模板的使用。类继承、多重继承的方法。&lt;/p&gt;
&lt;p&gt;8、什么是多态性，C++如何实现？&lt;/p&gt;
&lt;p&gt;9、如何在C++面向对象编程中体现“数据抽象”？&lt;/p&gt;
&lt;p&gt;10、如何用OOP实现更好的数据封装与代码重用？&lt;/p&gt;</content><category term="CPP"></category><category term="Tech"></category><category term="Programe"></category></entry><entry><title>Visual Studio使用快捷键</title><link href="https://leelongcrazy.github.io/visual-studioshi-yong-kuai-jie-jian.html" rel="alternate"></link><published>2021-01-28T17:00:00+08:00</published><updated>2021-01-28T17:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2021-01-28:/visual-studioshi-yong-kuai-jie-jian.html</id><summary type="html">&lt;p&gt;Visual Studio使用快捷键&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Visual Studio 使用技巧&lt;/h1&gt;
&lt;h2&gt;快捷键：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;快速启动(Ctrl + Q)：可进行搜索功能&lt;/li&gt;
&lt;li&gt;查看定义（Alt+F12）:可查看函数，结构体，变量等定义&lt;/li&gt;
&lt;li&gt;转到定义（F12）&lt;/li&gt;
&lt;li&gt;文件切换（Ctrl+K+O）&lt;/li&gt;
&lt;li&gt;字体放大：Ctrl+Shift+ .&lt;/li&gt;
&lt;li&gt;字体缩小：Ctrl+Shift+ ,&lt;/li&gt;
&lt;li&gt;全局搜索： Ctrl+Shift+F&lt;/li&gt;
&lt;li&gt;代码注释： Ctrl+K+C&lt;/li&gt;
&lt;li&gt;取消注释： Ctrl+K+U&lt;/li&gt;
&lt;li&gt;快速跳转文件：Ctrl+，（逗号）&lt;/li&gt;
&lt;li&gt;搜索：Ctrl+F；&lt;/li&gt;
&lt;li&gt;替换：Ctrl+H&lt;/li&gt;
&lt;li&gt;跳转到下一个搜索关键字：F3&lt;/li&gt;
&lt;li&gt;跳转到上一个搜索关键字：Shift+ F3&lt;/li&gt;
&lt;li&gt;跳转到指定行：Ctrl+G&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目相关&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新建：Ctrl+Shift+N&lt;/li&gt;
&lt;li&gt;打开：Ctrl+Shift+O&lt;/li&gt;
&lt;li&gt;新添加项：Ctrl+Shift+A&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;调试相关：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开始调试：F5&lt;/li&gt;
&lt;li&gt;调试（重新启动）：Ctrl+Shift+F5&lt;/li&gt;
&lt;li&gt;开始调试（开始执行不调试）: Ctrl + F5&lt;/li&gt;
&lt;li&gt;设置断点：F9&lt;/li&gt;
&lt;li&gt;取消所有断点：Ctrl+Shift+F9&lt;/li&gt;
&lt;li&gt;下一步（逐过程）：F10&lt;/li&gt;
&lt;li&gt;下一步（逐语句）：F11&lt;/li&gt;
&lt;li&gt;停止调试：Shift + F5&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决方法相关：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成解决方案: F7&lt;/li&gt;
&lt;li&gt;重新生成解决方案：Ctrl+Alt+F7&lt;/li&gt;
&lt;li&gt;对解决方案运行代码分析：Alt+F11&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;格式化代码相关（类似于autopep）；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全部文档：Ctrl+K+D&lt;/li&gt;
&lt;li&gt;选中代码：Ctrl+K+F&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;复制、剪切、删除代码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复制整行代码：Ctrl+C&lt;/li&gt;
&lt;li&gt;剪切整行：Ctrl+X&lt;/li&gt;
&lt;li&gt;删除整行：Ctrl+L&lt;/li&gt;
&lt;li&gt;删除之词尾：Ctrl+Delete&lt;/li&gt;
&lt;li&gt;删除之词头：Ctrl+Backspace&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大小写转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;转小写：Ctrl+U&lt;/li&gt;
&lt;li&gt;转大写：Ctrl+Shift+U&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在光标所在行上方或下方插入一行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上面插入一空行：Ctrl+Enter&lt;/li&gt;
&lt;li&gt;下面插入一空行：Ctrl+Shift+Enter&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;智能提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ctrl+J&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Alt+ -&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入代码段：Ctrl+K+X&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;插入外侧代码：Ctrl+K+S&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;隐藏、显示代码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前代码段：Ctrl+M+M&lt;/li&gt;
&lt;li&gt;全部代码：Ctrl+M+ L&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;回到上一个光标位置、前进到下一个光标位置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;回到上一个光标位置：Ctrl+ -&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前进到下一个光标位置：Ctrl+Shift+ -&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全屏显示、退出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Shift+Alt+Enter&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;窗口切换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ctrl+Tab：打开IDE导航，获得鸟瞰图&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;相关资料：&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf"&gt;Visual Studio Code keyboard shortcuts for Windows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.jianshu.com/p/13668765fc7a"&gt;visual studio 2015快捷键整理&lt;/a&gt;&lt;/p&gt;</content><category term="Software"></category><category term="Programe"></category></entry><entry><title>VUE学习笔记</title><link href="https://leelongcrazy.github.io/vuexue-xi-bi-ji.html" rel="alternate"></link><published>2020-12-23T17:00:00+08:00</published><updated>2020-12-23T17:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2020-12-23:/vuexue-xi-bi-ji.html</id><summary type="html">&lt;p&gt;VUE学习笔记&lt;/p&gt;</summary><content type="html">&lt;h1&gt;VUE学习笔记&lt;/h1&gt;
&lt;h2&gt;Vue 对象&lt;/h2&gt;
&lt;h5&gt;new Vue()产生实例时传入的常用的选项&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;el: 通过CSS选择器或者HTMLElement实例的方式，提供一个在页面上已存在的DOM元素作为Vue实例的挂在目标。&lt;/li&gt;
&lt;li&gt;data：用于定义属性&lt;/li&gt;
&lt;li&gt;methods：用于定义函数。Vue实例的事件，用于事件绑定&lt;/li&gt;
&lt;li&gt;template : 字符串模板，将会替换挂载的元素&lt;/li&gt;
&lt;li&gt;render : 字符串模板的代替方案&lt;/li&gt;
&lt;li&gt;props : 用于接收来自父组件的数据&lt;/li&gt;
&lt;li&gt;computed : 计算属性，用于简化模板的复杂数据计算&lt;/li&gt;
&lt;li&gt;watch : 观察Vue实例变化的一个表达式或计算属性函数&lt;/li&gt;
&lt;li&gt;directives : 自定义命令&lt;/li&gt;
&lt;li&gt;filters : 过滤器&lt;/li&gt;
&lt;li&gt;components : 组件&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;vm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Vue&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
  &lt;span class="c1"&gt;// ...一些选项&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;vm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;$data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 获取 data&lt;/span&gt;
&lt;span class="nx"&gt;vm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;$props&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 获取 props&lt;/span&gt;
&lt;span class="nx"&gt;vm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;$el&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 获取挂载元素&lt;/span&gt;
&lt;span class="nx"&gt;vm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;$options&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 获取 Vue 实例的初始选项&lt;/span&gt;
&lt;span class="nx"&gt;vm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;$parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 获取父实例&lt;/span&gt;
&lt;span class="nx"&gt;vm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;$root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 获取根实例&lt;/span&gt;
&lt;span class="nx"&gt;vm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;$children&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 获取当前实例的直接子组件&lt;/span&gt;
&lt;span class="nx"&gt;vm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;$refs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 获取持有注册过 ref 特性 的所有 DOM 元素和组件实例&lt;/span&gt;

&lt;span class="nx"&gt;vm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;$watch&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 观察 Vue 实例变化的一个表达式或计算属性函数&lt;/span&gt;
&lt;span class="nx"&gt;vm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;$set&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新&lt;/span&gt;
&lt;span class="nx"&gt;vm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;$delete&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 删除对象的属性。如果对象是响应式的，确保删除能触发更新视图&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;模板语法&lt;/h2&gt;
&lt;h3&gt;插值&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文本 {{ }}&lt;/li&gt;
&lt;li&gt;html: 使用v-html 指令用于输出HTML&lt;/li&gt;
&lt;li&gt;属性：使用v-bind 指令用于绑定HTML属性中的值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;表达式： 支持JS表达式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;指令： &lt;/li&gt;
&lt;li&gt;v-if&lt;/li&gt;
&lt;li&gt;v-on     它用于监听 DOM 事件&lt;/li&gt;
&lt;li&gt;v-for&lt;/li&gt;
&lt;li&gt;v-bind   属性值绑定&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;用户输入 ：v-model 指令来实现双向数据绑定&lt;/h3&gt;
&lt;h3&gt;过滤器：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;{{ message | filterA | filterB }} // &lt;/li&gt;
&lt;li&gt;{{ message | filterA('arg1', arg2) }}  过滤器是JavaScript函数，可以接受参数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;缩写&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;v-bind的缩写：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;html
    &amp;lt;!-- 完整语法 --&amp;gt;
    &amp;lt;a v-bind:href="url"&amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;!-- 缩写 --&amp;gt;
    &amp;lt;a :href="url"&amp;gt;&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;v-on 的缩写：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;html
    &amp;lt;!-- 完整语法 --&amp;gt;
    &amp;lt;a v-on:click="doSomething"&amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;!-- 缩写 --&amp;gt;
    &amp;lt;a @click="doSomething"&amp;gt;&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;条件与循环&lt;/h2&gt;
&lt;h3&gt;条件语句&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;v-if&lt;/li&gt;
&lt;li&gt;v-else&lt;/li&gt;
&lt;li&gt;v-else-if&lt;/li&gt;
&lt;li&gt;v-show: 可以根据条件展示元素&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;循环语句&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;v-for&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第一个参数为数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二个参数为键名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三个参数为索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;html
    &amp;lt;div id="app"&amp;gt;
      &amp;lt;ul&amp;gt;
        &amp;lt;li v-for="(value, key, index) in object"&amp;gt;
         {{ index }}. {{ key }} : {{ value }}
        &amp;lt;/li&amp;gt;
      &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;计算属性&lt;/h2&gt;
&lt;p&gt;计算属性关键词：computed，在处理一些复杂逻辑时是很有用的。&lt;/p&gt;
&lt;p&gt;利用计算属性实现字符串的翻转：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;div&lt;/span&gt; &lt;span class="na"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;app&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;原始字符串: {{ message }}&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;计算后反转字符串: {{ reversedMessage }}&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;div&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;vm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Vue&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
  &lt;span class="nx"&gt;el&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;#app&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;message&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Runoob!&amp;#39;&lt;/span&gt;
  &lt;span class="p"&gt;},&lt;/span&gt;
  &lt;span class="nx"&gt;computed&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// 计算属性的 getter&lt;/span&gt;
    &lt;span class="nx"&gt;reversedMessage&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;// `this` 指向 vm 实例&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;message&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="nx"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h6&gt;computed vs methods&lt;/h6&gt;
&lt;p&gt;可以用methods来替代computed，效果都是一样的，但是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用 methods ，在重新渲染的时候，函数总会重新调用执行。&lt;/p&gt;
&lt;h2&gt;监听属性&lt;/h2&gt;
&lt;h3&gt;watch&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;目的是响应数据的变化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;深度监听：deep: true &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;样式绑定&lt;/h2&gt;
&lt;h3&gt;class属性绑定&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;html 
  &amp;lt;div v-bind:class="{ 'active': isActive }"&amp;gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;事件处理器&lt;/h2&gt;
&lt;p&gt;v-on&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt;&amp;lt;!-- 同上 --&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;input&lt;/span&gt; &lt;span class="na"&gt;v-on:keyup&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="na"&gt;enter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;submit&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;!-- 缩写语法 --&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;input&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="na"&gt;keyup&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="na"&gt;enter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;submit&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;事件修饰符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.stop&lt;/code&gt; - 阻止冒泡&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.prevent&lt;/code&gt; - 阻止默认事件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.capture&lt;/code&gt; - 阻止捕获&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.self&lt;/code&gt; - 只监听触发该元素的事件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.once&lt;/code&gt; - 只触发一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.left&lt;/code&gt; - 左键事件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.right&lt;/code&gt; - 右键事件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.middle&lt;/code&gt; - 中间滚轮事件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;监听键盘事件时添加按键修饰符，以下是按键别名：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.enter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.tab&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.delete&lt;/code&gt; (捕获 "删除" 和 "退格" 键)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.esc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.space&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.up&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.down&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.left&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.right&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.ctrl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.alt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.shift&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.meta&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;表单的处理&lt;/h2&gt;
&lt;h3&gt;v-model&lt;/h3&gt;
&lt;p&gt;修饰符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.lazy&lt;/code&gt;  输入框在change事件中变化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.number&lt;/code&gt;  将输入值转换为Number类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.trim&lt;/code&gt;  自动过滤输入的首尾空格&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;VUE 组件&lt;/h2&gt;
&lt;p&gt;组件（component）是VUE.js最强大的功能之一。&lt;/p&gt;
&lt;p&gt;组件可以扩展HTML元素，封装可重用的代码。&lt;/p&gt;
&lt;p&gt;注册全局组件语法格式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Vue.component(tagName, options)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;tagName为组件名，options为配置选项。&lt;/p&gt;
&lt;p&gt;组件的调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;tagName&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;tagName&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;分类：全局组件和局部组件&lt;/p&gt;
&lt;h3&gt;自定义事件&lt;/h3&gt;
&lt;p&gt;组件中的 data 不是一个对象，而是一个函数，这样的好处就是每个实例可以维护一份被返回对象的独立的拷贝，如果 data 是一个对象则会影响到其他实例&lt;/p&gt;
&lt;h3&gt;自定义指令&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;div&lt;/span&gt; &lt;span class="nx"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;app&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;页面载入时&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nx"&gt;input&lt;/span&gt; &lt;span class="nx"&gt;元素自动获取焦点&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;/p&amp;gt;&lt;/span&gt;
    &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;input&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;focus&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;/div&amp;gt;&lt;/span&gt;

&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;script&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="c1"&gt;// 注册一个全局自定义指令 v-focus&lt;/span&gt;
&lt;span class="nx"&gt;Vue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;directive&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;focus&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// 当绑定元素插入到 DOM 中。&lt;/span&gt;
  &lt;span class="nx"&gt;inserted&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;el&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// 聚焦元素&lt;/span&gt;
    &lt;span class="nx"&gt;el&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;focus&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="c1"&gt;// 创建根实例&lt;/span&gt;
&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Vue&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
  &lt;span class="nx"&gt;el&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;#app&amp;#39;&lt;/span&gt;
&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;消息传递&lt;/h2&gt;
&lt;p&gt;父组件可以使用 props 把数据传给子组件&lt;/p&gt;
&lt;p&gt;子组件可以使用 $emit 触发父组件的自定义事件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nx"&gt;vm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;$emit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="nx"&gt;event&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//触发当前实例上的事件&lt;/span&gt;

&lt;span class="nx"&gt;vm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;$on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="nx"&gt;event&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;fn&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//监听event事件后运行 fn&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;VUE 的过渡和动画&lt;/h2&gt;
&lt;p&gt;实现过渡效果的组件：transition&lt;/p&gt;
&lt;h2&gt;Vue.js Ajax(axios)&lt;/h2&gt;
&lt;p&gt;Vue.js 2.0 版本推荐使用 axios 来完成 ajax 请求。&lt;/p&gt;
&lt;p&gt;Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中。&lt;/p&gt;
&lt;p&gt;Github开源地址： https://github.com/axios/axios&lt;/p&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;script&lt;/span&gt; &lt;span class="na"&gt;src&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;https://cdn.staticfile.org/axios/0.18.0/axios.min.js&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="Web"></category><category term="VUE"></category></entry><entry><title>oh-my-zsh使用指南</title><link href="https://leelongcrazy.github.io/oh-my-zshshi-yong-zhi-nan.html" rel="alternate"></link><published>2020-08-29T17:00:00+08:00</published><updated>2020-08-29T17:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2020-08-29:/oh-my-zshshi-yong-zhi-nan.html</id><summary type="html">&lt;p&gt;如果熟悉Linux系统，一定要打交道的就是SHELL语言，掌握使用SHELL的高效方法，做起很多事情来得心应手，最开始我只熟悉bash，当我安装完zsh,并使用oh my zsh套件以后，太震撼了。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;如果熟悉Linux系统，一定要打交道的就是SHELL语言，掌握使用SHELL的高效方法，做起很多事情来得心应手，最开始我只熟悉bash，当我安装完zsh,并使用oh my zsh套件以后，太震撼了。&lt;/h2&gt;
&lt;h3&gt;前些天拿出吃了很久灰的树莓派，借这次安装zsh的机会，整理出来了安装的过程。&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;查看当前使用SHELL，和已经安装的shell&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$SHELL&lt;/span&gt; &lt;span class="c1"&gt;# 查看当前使用SHELL&lt;/span&gt;
➜ cat /etc/shells  &lt;span class="c1"&gt;# 列出已经安装的shell&lt;/span&gt;
/bin/sh
/bin/bash
/usr/bin/bash
/bin/rbash
/usr/bin/rbash
/bin/dash
/usr/bin/dash
/usr/bin/tmux
/usr/bin/screen
/bin/zsh
/usr/bin/zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;如果没有显示&lt;code&gt;/bin/zsh&lt;/code&gt;，则执行下面安装命令&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# 我在Debian环境下安装的&lt;/span&gt;
sudo apt-get install zsh
&lt;span class="c1"&gt;# os x 下安装&lt;/span&gt;
brew install zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;安装完成后切换SHELL&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo chsh -s /bin/zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;重启操作系统生效&lt;/li&gt;
&lt;li&gt;可再次查看当前SHELL&lt;code&gt;echo $SHELL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;安装oh my zsh 有两种方式：&lt;code&gt;curl&lt;/code&gt;和&lt;code&gt;wget&lt;/code&gt;，&lt;a href="https://github.com/ohmyzsh/ohmyzsh"&gt;官方安装指导&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# use curl&lt;/span&gt;
sh -c &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;# or use wget&lt;/span&gt;
sh -c &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;7.安装完成后可编辑&lt;code&gt;.zshrc&lt;/code&gt;进行自定义设置，另外注意，原来&lt;code&gt;.bashrc&lt;/code&gt;下的配置在&lt;code&gt;zsh&lt;/code&gt;下仍然可以使用，&lt;code&gt;zsh&lt;/code&gt;是完全兼容&lt;code&gt;bash&lt;/code&gt;的。&lt;/p&gt;</content><category term="IT"></category><category term="Bash"></category><category term="zsh"></category></entry><entry><title>从远程仓库更新到本地</title><link href="https://leelongcrazy.github.io/cong-yuan-cheng-cang-ku-geng-xin-dao-ben-di.html" rel="alternate"></link><published>2020-08-05T15:00:00+08:00</published><updated>2020-08-05T15:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2020-08-05:/cong-yuan-cheng-cang-ku-geng-xin-dao-ben-di.html</id><summary type="html">&lt;p&gt;从远程仓库更新到本地&lt;/p&gt;</summary><content type="html">&lt;h2&gt;从远程仓库更新到本地&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用git fetch更新，相当于是从远程获取最新版本到本地，不会自动merge，可以先查看更新情况，再决定是否更新。有以下两种方式进行更新：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# 不额外建立临时分支，推荐这种更新方式&lt;/span&gt;
git fetch origin master
git log -p master..origin/master
git merge origin/master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;=&amp;gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# 通过建立临时分支实现更新&lt;/span&gt;
git fetch origin master:tmp &lt;span class="c1"&gt;# 从远程的origin的master主分支下载最新的版本到tmp分支上&lt;/span&gt;
git diff tmp &lt;span class="c1"&gt;# 比较本地的master分支和tmp分支的差别&lt;/span&gt;
git merge tmp &lt;span class="c1"&gt;# 合并到本地分支&lt;/span&gt;
git branch -D tmp &lt;span class="c1"&gt;# 删除本地临时分支&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;不推荐使用git pull 进行代码更新操作，相当于从远程代码获取更新并合并到本地，容易发生覆盖本地文件的错误。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git pull origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="IT"></category><category term="Tech"></category><category term="Github"></category><category term="Git"></category></entry><entry><title>brew源管理</title><link href="https://leelongcrazy.github.io/brewyuan-guan-li.html" rel="alternate"></link><published>2020-07-16T17:00:00+08:00</published><updated>2020-07-16T17:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2020-07-16:/brewyuan-guan-li.html</id><summary type="html">&lt;p&gt;brew源管理配置&lt;/p&gt;</summary><content type="html">&lt;h2&gt;brew源管理&lt;/h2&gt;
&lt;h3&gt;Mac系统下brew工具源管理&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;显示brew安装位置&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;brew --repo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;查看brew目前所使用的源&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git -C &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;brew --repo&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; remote get-url origin
git -C &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;brew --repo&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt; homebrew/core&amp;quot;&lt;/span&gt; remote get-url origin
git -C &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;brew --repo&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt; homebrew/cask)&amp;quot;&lt;/span&gt; remote get-url origin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;更换为清华源&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git -C &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;brew --repo&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git
git -C &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;brew --repo&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt; homebrew/core&amp;quot;&lt;/span&gt; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git
git -C &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;brew --repo homebrew/cask&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git
brew update &lt;span class="c1"&gt;# 执行更新&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;恢复默认源&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git -C &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;brew --repo&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; remote set-url origin https://github.com/Homebrew/brew.git
git -C &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;brew --repo homebrew/core&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; remote set-url origin https://github.com/Homebrew/homebrew-core.git
git -C &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;brew --repo homebrew/cask&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; remote set-url origin https://github.com/Homebrew/homebrew-cask.git
brew update &lt;span class="c1"&gt;# 执行更新&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="IT"></category><category term="Tech"></category><category term="os"></category></entry><entry><title>在Mac上安装python虚拟环境管理工具</title><link href="https://leelongcrazy.github.io/Install-virtualenv-on-Mac.html" rel="alternate"></link><published>2020-05-29T17:00:00+08:00</published><updated>2020-05-29T17:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2020-05-29:/Install-virtualenv-on-Mac.html</id><summary type="html">&lt;p&gt;在Mac上安装python虚拟环境管理工具&lt;/p&gt;</summary><content type="html">&lt;h2&gt;在Mac上安装python虚拟环境管理工具&lt;/h2&gt;
&lt;h4&gt;在Mac上安装完homebrew以后，测试下工具就安装python3，安装完以后发现和系统中的一些工具默认以python2执行的冲突了，执行命令的时候会报出多行错误信息，害得我一度认为我把Mac系统给玩坏了，后来重新安装了一遍python2 的pip工具，问题解决了。&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://www.cnblogs.com/kaid/p/8227635.html" title="在Mac上搭建Python虚拟环境"&gt;避免以后安装的库文件和Mac系统环境的依赖库重叠，最好的办法莫过于多创建虚拟环境。&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;安装virtualenv&lt;/h3&gt;
&lt;h5&gt;安装执行：&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ pip3 install virtualenv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;创建虚拟环境，激活，退出：&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ virtualenv test_env
$ &lt;span class="nb"&gt;cd&lt;/span&gt; test_env  &lt;span class="c1"&gt;# 进入虚拟环境目录&lt;/span&gt;
$ &lt;span class="nb"&gt;source&lt;/span&gt; bin/activate &lt;span class="c1"&gt;# 激活虚拟环境&lt;/span&gt;
$ deactivate  &lt;span class="c1"&gt;# 退出虚拟环境&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;安装virtualenvwrapper&lt;/h3&gt;
&lt;h5&gt;Virtaulenvwrapper是virtualenv的扩展包，可以更方便地新增，删除，复制，切换虚拟环境。&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;# 安装&lt;/span&gt;
&lt;span class="err"&gt;$ pip3 install virtualenvwrapper&lt;/span&gt;
&lt;span class="err"&gt;# 创建一个隐藏文件夹用以存放虚拟环境&lt;/span&gt;
&lt;span class="err"&gt;$ mkdir .virtualenvs&lt;/span&gt;
&lt;span class="err"&gt;# 记住下面两个命令显示的路径&lt;/span&gt;
&lt;span class="err"&gt;$ which virtualenvwrapper.sh&lt;/span&gt;
&lt;span class="err"&gt;$ which python3&lt;/span&gt;
&lt;span class="err"&gt;# 编辑zsh配置文件&lt;/span&gt;
&lt;span class="err"&gt;$ vi .zshrc&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;在末尾添加下面的内容&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;export WORKON_HOME=&amp;quot;~/.virtualenvs&amp;quot;&lt;/span&gt;
&lt;span class="err"&gt;export VIRTUALENVWRAPPER_PYTHON=&amp;quot;/usr/local/bin/python3&amp;quot;&lt;/span&gt;
&lt;span class="err"&gt;source /usr/local/bin/virtualenvwrapper.sh&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;# 刷新shell&lt;/span&gt;
&lt;span class="err"&gt;$ source .zshrc&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;virtualenvwrapper常用命令&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;virtualenv&lt;/span&gt; &lt;span class="n"&gt;environments&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;lsvirtualenv&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;change&lt;/span&gt; &lt;span class="n"&gt;virtualenv&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;workon&lt;/span&gt; &lt;span class="n"&gt;virtualenv&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;installed&lt;/span&gt; &lt;span class="n"&gt;packages&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;lssitepackages&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;enter&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="k"&gt;current&lt;/span&gt; &lt;span class="n"&gt;virtualenv&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;s path&lt;/span&gt;
&lt;span class="s1"&gt;$ cdvirtualenv&lt;/span&gt;

&lt;span class="s1"&gt;# 5.enter the current virtualenv&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;site&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;packages&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;cdsitepackages&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;copy&lt;/span&gt; &lt;span class="n"&gt;virtualenv&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;cpvirtualenv&lt;/span&gt; &lt;span class="n"&gt;env1&lt;/span&gt; &lt;span class="n"&gt;env2&lt;/span&gt;
&lt;span class="n"&gt;Copying&lt;/span&gt; &lt;span class="n"&gt;env1&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;env2&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;virtualenv&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;deactivate&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;virtualenv&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;rmvirtualenv&lt;/span&gt; &lt;span class="n"&gt;virtualenv&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;增加pyenv管理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;安装：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;bash
    brew install pyenv
    # or 
    apt install pyenv&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pyenv &lt;span class="m"&gt;1&lt;/span&gt;.2.21
Usage: pyenv &amp;lt;command&amp;gt; &lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;args&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt;

常用命令:
   --version   显示版本信息
   activate    激活虚拟环境
   commands    列出所有可用pyenv命令
   deactivate   退出虚拟环境
   &lt;span class="nb"&gt;exec&lt;/span&gt;        按选定python版本运行
   global      设置或显示全局python版本
   &lt;span class="nb"&gt;help&lt;/span&gt;        帮助信息
   hooks       List hook scripts &lt;span class="k"&gt;for&lt;/span&gt; a given pyenv &lt;span class="nb"&gt;command&lt;/span&gt;
   init        Configure the shell environment &lt;span class="k"&gt;for&lt;/span&gt; pyenv
   install     Install a Python version using python-build
   &lt;span class="nb"&gt;local&lt;/span&gt;       Set or show the &lt;span class="nb"&gt;local&lt;/span&gt; application-specific Python version&lt;span class="o"&gt;(&lt;/span&gt;s&lt;span class="o"&gt;)&lt;/span&gt;
   prefix      Display prefix &lt;span class="k"&gt;for&lt;/span&gt; a Python version
sed: RE error: illegal byte sequence
   rehash      Rehash pyenv shims &lt;span class="o"&gt;(&lt;/span&gt;run this after installing executables&lt;span class="o"&gt;)&lt;/span&gt;
   root        Display the root directory where versions and shims are kept
   shell       Set or show the shell-specific Python version
   shims       List existing pyenv shims
   uninstall   Uninstall a specific Python version
   version     Show the current Python version&lt;span class="o"&gt;(&lt;/span&gt;s&lt;span class="o"&gt;)&lt;/span&gt; and its origin
   version-file   Detect the file that sets the current pyenv version
   version-name   Show the current Python version
   version-origin   Explain how the current Python version is &lt;span class="nb"&gt;set&lt;/span&gt;
   versions    List all Python versions available to pyenv
   virtualenv   Create a Python virtualenv using the pyenv-virtualenv plugin
   virtualenv-delete   Uninstall a specific Python virtualenv
   virtualenv-init   Configure the shell environment &lt;span class="k"&gt;for&lt;/span&gt; pyenv-virtualenv
   virtualenv-prefix   Display real_prefix &lt;span class="k"&gt;for&lt;/span&gt; a Python virtualenv version
   virtualenvs   List all Python virtualenvs found in &lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;$PYENV_ROOT&lt;/span&gt;/versions/*&lt;span class="sb"&gt;`&lt;/span&gt;.
   whence      List all Python versions that contain the given executable
   which       Display the full path to an executable


&lt;span class="c1"&gt;## 示例：&lt;/span&gt;
&lt;span class="c1"&gt;# 1.创建虚拟环境&lt;/span&gt;
pyenv virtualenv &lt;span class="m"&gt;3&lt;/span&gt;.8.6 virtualenv-name
&lt;span class="c1"&gt;# 2. 激活虚拟环境&lt;/span&gt;
pyenv activate virtualenv-name
&lt;span class="c1"&gt;# 3. 列出所有虚拟环境&lt;/span&gt;
pyenv virtualenvs
&lt;span class="c1"&gt;# 4. 删除虚拟环境&lt;/span&gt;
pyenv virtualenv-delete virtualenv-name
&lt;span class="c1"&gt;# 5. 推出虚拟环境&lt;/span&gt;
pyenv deactive
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="IT"></category><category term="Python"></category><category term="Code"></category></entry><entry><title>oh my zsh &amp;&amp; git</title><link href="https://leelongcrazy.github.io/oh-my-zsh-git.html" rel="alternate"></link><published>2020-05-28T17:00:00+08:00</published><updated>2020-05-28T17:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2020-05-28:/oh-my-zsh-git.html</id><summary type="html">&lt;p&gt;oh my zsh下git命令别名&lt;/p&gt;</summary><content type="html">&lt;h2&gt;oh my zsh --- git.md&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;g&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;git
&lt;span class="nv"&gt;ga&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git add&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gaa&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git add --all&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gap&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git apply&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gapa&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git add --patch&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gau&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git add --update&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gav&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git add --verbose&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git branch&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gbD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git branch -D&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gba&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git branch -a&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gbd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git branch -d&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gbda&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git branch --no-color --merged | command grep -vE &amp;quot;^(\+|\*|\s*(master|develop|dev)\s*$)&amp;quot; | command xargs -n 1 git branch -d&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gbl&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git blame -b -w&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gbnm&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git branch --no-merged&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gbr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git branch --remote&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gbs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git bisect&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gbsb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git bisect bad&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gbsg&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git bisect good&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gbsr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git bisect reset&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gbss&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git bisect start&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git commit -v&amp;#39;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;#39;gc!&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git commit -v --amend&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gca&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git commit -v -a&amp;#39;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;#39;gca!&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git commit -v -a --amend&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gcam&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git commit -a -m&amp;#39;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;#39;gcan!&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git commit -v -a --no-edit --amend&amp;#39;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;#39;gcans!&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git commit -v -a -s --no-edit --amend&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gcb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git checkout -b&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gcd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git checkout develop&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gcf&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git config --list&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gcl&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git clone --recurse-submodules&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gclean&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git clean -id&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gcm&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git checkout master&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gcmsg&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git commit -m&amp;#39;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;#39;gcn!&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git commit -v --no-edit --amend&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gco&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git checkout&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gcount&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git shortlog -sn&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gcp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git cherry-pick&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gcpa&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git cherry-pick --abort&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gcpc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git cherry-pick --continue&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gcs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git commit -S&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gcsm&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git commit -s -m&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git diff&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gdca&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git diff --cached&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gdct&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git describe --tags $(git rev-list --tags --max-count=1)&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gdcw&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git diff --cached --word-diff&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gds&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git diff --staged&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gdt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git diff-tree --no-commit-id --name-only -r&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gdw&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git diff --word-diff&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gf&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git fetch&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gfa&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git fetch --all --prune&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gfg&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git ls-files | grep&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gfo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git fetch origin&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gg&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git gui citool&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gga&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git gui citool --amend&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;ggpull&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git pull origin &amp;quot;$(git_current_branch)&amp;quot;&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;ggpur&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;ggu
&lt;span class="nv"&gt;ggpush&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git push origin &amp;quot;$(git_current_branch)&amp;quot;&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;ggsup&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git branch --set-upstream-to=origin/$(git_current_branch)&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;ghh&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git help&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gignore&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git update-index --assume-unchanged&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gignored&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git ls-files -v | grep &amp;quot;^[[:lower:]]&amp;quot;&amp;#39;&lt;/span&gt;
git-svn-dcommit-push&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git svn dcommit &amp;amp;&amp;amp; git push github master:svntrunk&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;\gitk --all --branches&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gke&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;\gitk --all $(git log -g --pretty=%h)&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gl&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git pull&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;glg&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git log --stat&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;glgg&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git log --graph&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;glgga&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git log --graph --decorate --all&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;glgm&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git log --graph --max-count=10&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;glgp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git log --stat -p&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;glo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git log --oneline --decorate&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;glod&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git log --graph --pretty=&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\&amp;#39;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)&amp;lt;%an&amp;gt;%Creset&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;glods&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git log --graph --pretty=&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\&amp;#39;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)&amp;lt;%an&amp;gt;%Creset&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\&amp;#39;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; --date=short&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;glog&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git log --oneline --decorate --graph&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gloga&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git log --oneline --decorate --graph --all&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;glol&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git log --graph --pretty=&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\&amp;#39;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&amp;lt;%an&amp;gt;%Creset&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;glola&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git log --graph --pretty=&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\&amp;#39;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&amp;lt;%an&amp;gt;%Creset&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\&amp;#39;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; --all&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;glols&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git log --graph --pretty=&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\&amp;#39;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&amp;lt;%an&amp;gt;%Creset&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\&amp;#39;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; --stat&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;glp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;_git_log_prettily
&lt;span class="nv"&gt;glum&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git pull upstream master&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gm&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git merge&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gma&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git merge --abort&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gmom&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git merge origin/master&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gmt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git mergetool --no-prompt&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gmtvim&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git mergetool --no-prompt --tool=vimdiff&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gmum&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git merge upstream/master&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;goproxy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;export http_proxy=http://127.0.0.1:1087 https_proxy=https://127.0.0.1:1087&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git push&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gpd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git push --dry-run&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gpf&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git push --force-with-lease&amp;#39;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;#39;gpf!&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git push --force&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gpoat&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git push origin --all &amp;amp;&amp;amp; git push origin --tags&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gpristine&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git reset --hard &amp;amp;&amp;amp; git clean -dfx&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gpsup&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git push --set-upstream origin $(git_current_branch)&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gpu&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git push upstream&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gpv&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git push -v&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git remote&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gra&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git remote add&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git rebase&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grba&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git rebase --abort&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grbc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git rebase --continue&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grbd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git rebase develop&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grbi&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git rebase -i&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grbm&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git rebase master&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grbs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git rebase --skip&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grep&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;grep  --color=auto --exclude-dir={.bzr,CVS,.git,.hg,.svn}&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grev&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git revert&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grh&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git reset&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grhh&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git reset --hard&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grm&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git rm&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grmc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git rm --cached&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grmv&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git remote rename&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;groh&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git reset origin/$(git_current_branch) --hard&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grrm&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git remote remove&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git restore&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git remote set-url&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grss&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git restore --source&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;cd &amp;quot;$(git rev-parse --show-toplevel || echo .)&amp;quot;&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gru&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git reset --&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grup&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git remote update&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;grv&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git remote -v&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gsb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git status -sb&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gsd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git svn dcommit&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gsh&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git show&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gsi&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git submodule init&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gsps&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git show --pretty=short --show-signature&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gsr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git svn rebase&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gss&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git status -s&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gst&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git status&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gsta&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git stash push&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gstaa&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git stash apply&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gstall&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git stash --all&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gstc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git stash clear&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gstd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git stash drop&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gstl&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git stash list&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gstp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git stash pop&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gsts&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git stash show --text&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gsu&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git submodule update&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gsw&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git switch&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gswc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git switch -c&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gtl&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;gtl(){ git tag --sort=-v:refname -n -l ${1}* }; noglob gtl&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gts&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git tag -s&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gtv&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git tag | sort -V&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gunignore&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git update-index --no-assume-unchanged&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gunwip&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git log -n 1 | grep -q -c &amp;quot;\-\-wip\-\-&amp;quot; &amp;amp;&amp;amp; git reset HEAD~1&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gup&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git pull --rebase&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gupa&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git pull --rebase --autostash&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gupav&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git pull --rebase --autostash -v&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gupv&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git pull --rebase -v&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gwch&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git whatchanged -p --abbrev-commit --pretty=medium&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;gwip&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git add -A; git rm $(git ls-files --deleted) 2&amp;gt; /dev/null; git commit --no-verify --no-gpg-sign -m &amp;quot;--wip-- [skip ci]&amp;quot;&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="IT"></category><category term="Tech"></category><category term="Git，zsh"></category></entry><entry><title>物联网的下一步演化</title><link href="https://leelongcrazy.github.io/wu-lian-wang-de-xia-yi-bu-yan-hua.html" rel="alternate"></link><published>2020-03-05T13:00:00+08:00</published><updated>2020-03-05T13:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2020-03-05:/wu-lian-wang-de-xia-yi-bu-yan-hua.html</id><summary type="html">&lt;p&gt;物联网的下一步演化,文章翻译&lt;/p&gt;</summary><content type="html">&lt;h1&gt;物联网的下一步演化&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;写在前面的话：&lt;br&gt;
这是我翻译的第一篇文章，翻译的最理想效果就是能达到：信、达、雅。&lt;br&gt;信，是能表达原文的意思准确；&lt;br&gt;达，通顺；&lt;br&gt;雅，在前面的基础上翻译的优美，有诗意。&lt;br&gt;我现在做的就是力求达到第一层面的要求。&lt;br&gt;想要学好英文，还需多做些这样的翻译。&lt;/p&gt;
&lt;hr&gt;
&lt;h5&gt;&lt;a href="https://medium.com/@jason.hope/this-is-the-next-step-in-evolution-for-iot-26077c7b8472" title="原文地址："&gt;人工智能（AI）和物联网（Iot）两项技术已经正在改变世界。即使你可能不知道这些技术是如何工作的，你也很可能在生活中密不可分的使用它们。当人工智能（AI）和物联网（Iot）在一起使用被称作物联人工智能（AIot），他们已具有变革商业世界和日常生活的能力。&lt;/a&gt;&lt;/h5&gt;
&lt;h3&gt;什么是IoT？&lt;/h3&gt;
&lt;p&gt;被称作物联网可能是由于宽带网络。因为互联网获得范围广泛，价格低廉，现在可以很容易的连接起来，不管它是在什么地方。更多的设备生产出来就具有Wi-Fi能力，因为网络连接太普遍了。&lt;/p&gt;
&lt;p&gt;幸亏有Wi-Fi技术和可联网设备的流行，公司正通过对可穿戴设备，头戴耳机，咖啡机和清洁机的联网形成更远的连接。智能门铃，比如Ring，允许你和外面世界的快递员视频对讲。到2022年，研究人员估计将会有290亿的联网设备。这些设备会组成连接人和物的物联网。&lt;/p&gt;
&lt;h3&gt;什么是AIot？&lt;/h3&gt;
&lt;p&gt;物联人工智能（The artificial intelligence of things）将是物联网概念的下一个舞台。当你将人工智能和物联网络融合起来，你的设备将突然具有收集数据和做决策的能力，在某种方式将不再需要你输入指令。你的咖啡壶可以决定开始制作咖啡，因为你的闹钟就要关闭了。与此同时，你的大门可能觉察到你离开了家并给家里的加热器发出一个关闭的信号。
所有这些智能设备可以帮助增加个性化和专业化生活的效率。物联人工智能允许你通过系统优化和数据分析放大商业表现。人工智能可以分析你活动产生的所有数据，作出更聪明，更好的决定。&lt;/p&gt;
&lt;h3&gt;物联人工智能该如何使用？&lt;/h3&gt;
&lt;p&gt;物联人工智能有各种各样的方式可以使用在你的商业上，以达到更好的表现和生产。这些个主意已经在创造的进程中，但是他们还不是你可以使用的唯一选择。最有可能的是，还有成百上千的应用还没有想出来。&lt;/p&gt;
&lt;h3&gt;快递机器人&lt;/h3&gt;
&lt;p&gt;当谷歌的Waymo正致力于创造无人驾驶汽车，自主送货机器人是另一项将使用物联人工智能的发明。
机器人将能够通过传感器收集关于它们正前进方向的环境数据。像自动驾驶汽车，这些机器人将能够使用人工智能智能地响应周围环境的变化。&lt;/p&gt;
&lt;h3&gt;智慧写字楼&lt;/h3&gt;
&lt;p&gt;使用物联人工智能，人们可以享有知道他们想要的温度和光亮度的写字楼。公司可以安装环境传感器用来收集关于环境数据或是使用者需要的数据。其他的传感器可以用来推断何时员工到达，所以员工就不需要再敲门进入。外加，人脸识别技术可以使监控员工在楼宇内的进出不需要用在每一个出入口安置安全警卫成为可能。&lt;/p&gt;
&lt;h3&gt;人工智能与零售&lt;/h3&gt;
&lt;p&gt;零售商店也将会被包括人工智能和物联网在内的技术革新。
商店可以用人脸识别技术来辨别进入商店的消费者。而且，人工智能可以使用消费者的数据预测他们的购物行为及他们从商店里需要什么东西。也可以利用数据来查明人体特征以便于商店向消费者推销实际需要的产品。&lt;/p&gt;
&lt;p&gt;这个概念不仅仅在理论上。Amazon Go已经提供了相似的体验。智能相机和人工智能使Amazon Go能确定每个消费者放进购物车的物品。然后，当他们带着购置物品离开商店的时候人工智能自动收银。&lt;/p&gt;
&lt;h3&gt;自主交通工具&lt;/h3&gt;
&lt;p&gt;自主交通将彻底颠覆多种工业。Uber，Lyft和传统的出租车将不再需要人来驾驶。人工智能将通过更高效的驾驶来降低燃料费用。特斯拉已经使用GPS，声纳和摄像机提供自动驾驶功能。&lt;/p&gt;
&lt;p&gt;此外自动驾驶汽车，人工智能和物联网使得车队管理更安全，更高效。像UPS这样的公司能够使用GPS来追踪雇员的定位，规划更聪明的路线。物联人工智能也使认出不安全的驾驶员，提升车队保养成为可能。&lt;/p&gt;
&lt;h3&gt;管理无人机交通&lt;/h3&gt;
&lt;p&gt;无人机可以潜在地使家庭递送比现在更便宜，迅捷。当前，唯一的问题是管理所有多种多样的航线。在机场，一名航空交通控制者管理航线以使飞机不能碰撞在一起。对无人机来说，物联人工智能可以致力于监控无人机，对交通流和航线管理做出调整。&lt;/p&gt;
&lt;p&gt;无人机可以减少交通拥堵。他们可以飞在交通工具上面跟踪拥堵，对交通流做出调整。在监控交通模式之后，无人机可以对速度限制做出改变。它们也可以帮助救护车在紧急情况下引导一条最快的路线出来。&lt;/p&gt;
&lt;p&gt;在1999年，Kevin Ashton发明了物联网的概念。在那时，物联网还只是纯粹的理论。在最近20年，对Ashton的理论成为现实来说，技术已经变得足够的便宜，足够的普遍。在人工智能的帮助下，在接下来的几年物联人工智能将实现令人激动的新发展。&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;原文：&lt;/h4&gt;</content><category term="Tech"></category><category term="Tech"></category><category term="Iot"></category></entry><entry><title>Python的故事 （Python‘s Tale)</title><link href="https://leelongcrazy.github.io/pythonde-gu-shi-pythons-tale.html" rel="alternate"></link><published>2020-02-28T17:00:00+08:00</published><updated>2020-02-28T17:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2020-02-28:/pythonde-gu-shi-pythons-tale.html</id><summary type="html">&lt;p&gt;Python的故事 （Python‘s Tale)翻译&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Python的故事 （Python‘s Tale)&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;写在前面的话：&lt;/p&gt;
&lt;p&gt;这是我翻译的第二篇文字，耗时四天完成，内容是&lt;a href="https://www.redhat.com/en/command-line-heroes/season-3/pythons-tale" title="Command Line Heroes Season 3 Python's Tale"&gt;开源Linux公司红帽的一期关于Python的播客音频&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;翻译使自己的英语进步更快，尤其在断句，俚语，时态语法，词汇等方面。&lt;/p&gt;
&lt;p&gt;这期播客节目聊到了Python的起源，发展与壮大的原因，也谈到了Python之父的离去，以及以后Python社区的发展。&lt;/p&gt;
&lt;p&gt;有说法讲Python未来的发展一定是搞黑客和机器学习的人接管，我深信不疑。&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;本期节目简介&lt;/h2&gt;
&lt;p&gt;一个仁慈的独裁者下台，改变了Python编程语言未来的航向。吉多·范·罗素姆（Guido van Rossum）的“权利转移“备忘录给编程语言进化方式带来关注。&lt;/p&gt;
&lt;p&gt;在这期节目中，艾米丽·莫尔豪斯（Emily Morehouse）把Python的技术扩展性和它的相关的社区连接起来。迈克尔·肯尼迪（Michael Kennedy）解释了为什么Python易于学习和对于建立Youtube和Instagram足够的强大。黛安·穆勒（Diane Mueller）强调Python社区如何在技术中如此广泛的包容性实践中起带头作用，包括社区主导的决策制定的兴起。&lt;/p&gt;
&lt;p&gt;有时，一个仁慈的独裁者可以创造一门编程语言。但是Python显示它的社区使其茁壮成长。&lt;/p&gt;
&lt;h2&gt;相关人物&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;艾米丽·莫尔豪斯（Emily Morehouse）：&lt;/strong&gt; Cuttlesoft公司工程总监和Python核心开发&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迈克尔·肯尼迪（Michael Kennedy）：&lt;/strong&gt; Python Bytes 和 Talk Python to Me两期的嘉宾，话说Python培训的创始人，Python软件基金会成员&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;黛安·穆勒（Diane Mueller）：&lt;/strong&gt; 红帽社区发展总监&lt;/p&gt;
&lt;h2&gt;音频文字记录&lt;/h2&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;2018年7月12日的早晨，世界各地的Python社区成员醒来，抓起一杯咖啡，并打开手提电脑。他们陆续发现一条来自仁慈的独裁者的信息。&lt;/p&gt;
&lt;p&gt;吉多·范·罗素姆（Guido van Rossum）是Python的发明者，世界上最伟大的编程语言之一，也可能是最伟大的编程语言，他写给了所有人。所以可以想象所有Python粉丝读完这些文字后的表情。&lt;/p&gt;
&lt;h3&gt;琐碎片段：&lt;/h3&gt;
&lt;p&gt;我在进行艰难的战斗，却发现有人不满意我的决定，我想完全从决策进程中离开，给自己一个无限期的假期，从仁慈的独裁者中离开。你们将依靠你们自己，我将不再是假装成功者。你们想要做什么。创造民主吗？还是无政府状态？&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;在这简短却震惊内外的备忘录中，吉多·范·罗素姆（Guido van Rossum）这个人已经领导了Python社区数十年之久。好吧，最后他还是躬身离开了。他的消息以“权力移交”命名，并且它将改变Python编程语言未来的前景。&lt;/p&gt;
&lt;p&gt;更深程度上，它也带来的所有编程语言在未来该如何进化，发展繁荣的问题。是否编程语言该被支持由一个给他们定型和使其连贯的仁慈的独裁者运行？或者，在开源的世界里，是否编程语言更像是根据一群完全不同话语者的行为成长起来，作出反应的说话语言，东西？据过去查明，Python社区是任何编程语言语言中成长最快的社区。&lt;/p&gt;
&lt;p&gt;我是萨隆·伊特巴莱克（Saron Yitbarek），这里是第三季的《代码英雄》，一个由红帽公司原创的播客节目。在上一季的《代码英雄》中，我们探索了一个被拉长的领域，从游戏，到失败的艺术，再到无服务开发。我们甚至最后追踪一个美国航天局的漫游者从火星表面穿过。但是有一件事似乎真的捕获了每个人的想象力，那就是格雷斯·琥珀的故事。她在编译器方面的工作促成了第一高级编程语言，COBOL。我们事后意识到格雷斯·琥珀的故事，仅仅是如此多编程语言重塑世界开发和操作中的一个。新的编程语言允许我们连接人类和机器。他们打开通向令人惊奇新可能性的大门。&lt;/p&gt;
&lt;p&gt;所以，第三季都是关于那些编程语言的。我们将会讨论JavaScript，我们将讨论BASIC，GO，Perl。而现在，我们正在讨论Python。Python将是我们旅程开始的地方，因为循着Python的故事，我们了解到关于所有编程语言的未来至关重要的真相。&lt;/p&gt;
&lt;p&gt;在Python仁慈的独裁者放弃他的宝座之后，对Python社区，吖，一个不小的损失，如何在独裁者离开之后组织事物？有人建议可以重塑他们的结构在哥老会礼拜之后。那个主意是行不通的。一般来说要想理解Python是如何整顿以及他对编程语言的未来意味着什么？我们不得不回到Python故事的起源。&lt;/p&gt;
&lt;h3&gt;吉多·范·罗素姆（Guido van Rossum）：&lt;/h3&gt;
&lt;p&gt;好吧，我用C语言写了所有代码，它变得有点单调乏味。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;这个人就是吉多·范·罗素姆（Guido van Rossum），Python的仁慈的独裁者。范·罗素姆曾经在阿姆斯特丹的著名公司CWI工作了几年，在那里他帮助开发ABC编程语言。现在，他正描述那个时候他用C语言工作并看到一种新编程语言的需求。&lt;/p&gt;
&lt;h3&gt;吉多·范·罗素姆（Guido van Rossum）：&lt;/h3&gt;
&lt;p&gt;它感觉好像有非常多的错误，而且进度缓慢。我正想，嗯，如果我们用ABC在这执行，我写一个完整的登录程序，仅仅需要15分钟，随后我用C语言再转向帐号管理程序或者其他什么，每项都要花费我一周的时间。我开始思考以某种方式想到一个方法在阿米巴环境中使用ABC的特征。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;这是我们在研究编程语言历史的过程中的一些发现。没有什么东西是新的，他们都是从旧的编程语言中借鉴的，为了胡乱拼凑解决方案。编程语言开始变形，进化，分支。当范·罗素姆对它们的潜力不满意，他想象一种编程语言可以连接C语言和Shell编程语言之间的缝隙。C语言过于臃肿，但与此同时，Shell脚本感觉太笨拙。两者之间有一个绝佳的点，而那个点就是由Python来填充。当范·罗素姆在1991年第一次发布Python，让人大开眼界，尤其对系统管理员来说。这是一个全能的脚本语言，不像之前的任何语言。&lt;/p&gt;
&lt;h3&gt;艾米丽·莫尔豪斯（Emily Morehouse）：&lt;/h3&gt;
&lt;p&gt;我第一次使用Python的时候，我已经彻底的喜欢上它了。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;这是艾米丽·莫尔豪斯（Emily Morehouse），当今的五位女性Python核心开发者之一。&lt;/p&gt;
&lt;h3&gt;艾米丽·莫尔豪斯（Emily Morehouse）：&lt;/h3&gt;
&lt;p&gt;我想我看到了赤裸裸的不同在像C++这样的第一编程语言和转向像Python这样的语言之间，你能真的看到编程语言的优雅和编程语言设计本身。你不需要必须处理内存管理冗杂的执行细节，它是更快建立事物，宽泛的多样化应用程序的最棒的方法。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;Python吸引力的关键是他的扩展能力。诸如像ABC的编程语言，在设计上单一庞大。对一个真正的社区没有办法帮助定义编程语言该如何工作。相比之下，范·罗素姆想要Python从一开始就是开放的，可扩展的。&lt;/p&gt;
&lt;h3&gt;艾米丽·莫尔豪斯（Emily Morehouse）：&lt;/h3&gt;
&lt;p&gt;当处理软件设计的时候，你将经常不得不带着要么存在软件，或者其他软件系统，并让他们在一起工作，如何设计软件以确保他们具有可扩展性是非常真实的价值之一。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;这个听起来好像是件不费脑筋的事，但并不是每一种编程语言都实现可扩展的水平，而Python从一开始就具有这种能力。真相就是如果一种编程语言，没有可扩展性烘培它，他最终将会随着他的成长倒在自己的重压之下。&lt;/p&gt;
&lt;h3&gt;艾米丽·莫尔豪斯（Emily Morehouse）：&lt;/h3&gt;
&lt;p&gt;Python被用一种非常有趣的方式设计，允许它的核心也具有扩展性。你竟然可以在系统运行的时候补不同的部件，所以如果你想知道引用了多少模块，或者你想知道是字符串类型还是整型类型，Python都允许你非常方便的做这些事情。&lt;/p&gt;
&lt;p&gt;Python的核心扩展能力一些被称作C语言扩展，或者C语言模块。所以Python竟然已经给你设计进入其他编程语言的入口，并且本质上，如果你写C语言扩展或C语言模块，那么就可以连接其他几百种编程语言，颇有点黑客Python的意思。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;这是所有关于用户的适应语言自身需求的能力。所以Python，正如吉多·范·罗素姆（Guido van Rossum）所遇见的那样，从不会限制在一个独裁者的视野。他的“权利移交“备忘录经过深思熟虑。范·罗素姆深知社区的影响有多强大，每个人在一起共事产生的力量有多强大。是的，他最后得了一个独裁者的称号，却是仁慈的独裁者。&lt;/p&gt;
&lt;h3&gt;艾米丽·莫尔豪斯（Emily Morehouse）：&lt;/h3&gt;
&lt;p&gt;我想Python能有一个如此多样的社区其中一个原因就是因为吉多。Python已经拥有女性核心开发者因为吉多想做出这种改变，并使其发生。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;娜奥米·塞德（Naomi Ceder），Python软件基金会的主席，曾经她定了一个基调，“Python，为语言而生，为社区而存在。”并且这或许是吉多·范·罗素姆（Guido van Rossum）最伟大的遗产。不止是Python，
他还为Python社区腾出空间。他使Python可以严格的扩展，但是在某种方式上，它可以在社会上扩展。它总给人们的增加留有余地。&lt;/p&gt;
&lt;h3&gt;艾米丽·莫尔豪斯（Emily Morehouse）：&lt;/h3&gt;
&lt;p&gt;你有如此多不同的Python应用程序，以至于根据定义，并通过构造，你的社区变得非常多种多样。所以这是真的，真的扩大社区范围。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;艾米丽·莫尔豪斯（Emily Morehouse）是Python核心开发者，Cuttlesoft公司的项目总监。&lt;/p&gt;
&lt;p&gt;一旦Python孵化出来，它就开始长得不像之前的样子。我看StackOverflow图表展示每种编程语言的讨论数量，关于Python的那一条火箭式上升。在2018年，人们在Google上搜索Python的条数已经超过了Kim Kardashian（美国的演员，企业家）。所有的一切已经使它跻身于和像有最常用编程语言称号的Java，C，C++比肩的地位。&lt;/p&gt;
&lt;p&gt;所以，所有的爱到底是怎么回事？为了查明，我找到了活在Python时代精神的中心的开发者迈克尔·肯尼迪。迈克尔不是第一次光临，已经做客两次关于Python的播客——话说Python于我（Talk Python to Me)和Python字节(Python Bytes)。我们将在展示简介中放一些链接，以便你们可以看一下。我和迈克尔会聊一聊Python是如何快速发展的。&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）：&lt;/h3&gt;
&lt;p&gt;如果你看了分析，调查，和像那样的东西，2012年似乎真的像是一个大拐点，最重大的事情发生在2012年，就是数据科学社区从像R的语言离开，还有其他一些东西聚集在Python上。自从那发生之后，势头就更猛了，有更多的机器学习库。比如，很多流行的机器学习库，优选考虑Python，然后才会考虑其他编程语言。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;是的，我也是这样理解的。当我想起Python的时候，我知道它可以用来做web开发；我知道有很多人依然用它构建web应用程序。但是我感觉它现在的核心是做数据科学那部分的事情。你认为是什么导致这种事情发生？为什么数据科学社区撤离，或者我不能说撤离，但确实从像R的语言离开？&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）：&lt;/h3&gt;
&lt;p&gt;是的，的确如此。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;那又起源于哪里呢？&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）：&lt;/h3&gt;
&lt;p&gt;我想在过渡中有两件事情。其中之一无疑是用Python来处理是真的，带引号的，“真的”编程语言，在这种感觉上你可以建立简单的事物。你可以画图表，做数据分析工具，诸如此类。而且你也可以构建Instagram，YouTube，所有这样其他的东西。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;是的，确实这样。&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）：&lt;/h3&gt;
&lt;p&gt;而像R这样的语言，是啊，从字面上看，确实这样。那些是用Python写成的。所以，他们使用的其他编程语言，当时像R语言，是做数据科学事情如科学分类，统计类型的编程语言。但是如果你想建立一个展示你成果的web应用程序，那你会使用什么呢？Node，还是Python，或者其他，你估计犹豫不决。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;好啊，有一个好点子了。&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）：&lt;/h3&gt;
&lt;p&gt;所以Python拥有完美的能力，基本上，它是真的编程语言。可以说是第一了。第二是，Python在这方面绝对是独一无二的，如我说，它是全能编程语言。我所说全能是，我可以是生物学家或者天体物理学家或者别的，我想探索一点数据的奥秘，我想载入‘CSV'格式的文件，运行一些命令并得到一张图片。我不需要理解类，静态方法，静态无返回主函数，聚合，连接等概念。你不需要经过一些编程语言做的那样经过所有的过程来开始。你只需要写几行代码，键入一条命令，就能运行了。&lt;/p&gt;
&lt;p&gt;然而，你可以建立像Instagram等等一类的东西。它绝对能成为你能使用的专业系统，但是你不会被强迫立马理解所有这些对一个大型应用程序的深奥的抽象概念。你可以接受他们，如果你想需要的话。这有意义吗？&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;是啊，是啊，这有很大的意义。所以我们讨论约在2012年转折点的时候，我正查找，做一些关于Python的调查，Python实际上是世界上用Google搜索最多的编程语言之一。&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）：&lt;/h3&gt;
&lt;p&gt;哇&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;你认为它在这个时候是真的在上升，增长吗？&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）： 13：47&lt;/h3&gt;
&lt;p&gt;我确实认为它正在上升，并且正在增长。我们讨论这几年的最新数字，确实有更多企业组织正在使用Python。他们过去使用.Net，Java，也许有些C语言。这就是答案，现在Python正在开始自己的方式，我认为它正越来越侧重于那些环境一些，并以此，和数据科学走的更近。这就像，嗯，很明显我们要使用Jupyter Lab和所有酷炫的笔记本工具一样。这就是Python。&lt;/p&gt;
&lt;p&gt;数据科学并不具有这样的遗留代码库的故事。如果我想开始一个新项目探究某些广告活动或者科学结果，对旧的东西不要太大的依赖。模型和数据已过期，所以数据科学界更容易切换技术或保持最新状态。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）： 14:37&lt;/h3&gt;
&lt;p&gt;这是个好主意。&lt;/p&gt;
&lt;p&gt;迈克尔·肯尼迪（Michael Kennedy）： 
是的，谢谢。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;是啊。而且似乎听来它不会很快停止增长。听起来像是要继续保持增长，而且势头还在不断增长。你认为什么会影响它最快，向前的增长？&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）： 14:52&lt;/h3&gt;
&lt;p&gt;我觉得这就是个往下坡滚的球。我们有你能使用Python的所有库文件，包文件。我们现在有一个难以置信的数字。一两年前是100，000。现在已经是170，000个包或项目。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;哇&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）： 15:10&lt;/h3&gt;
&lt;p&gt;你可能仅需要几行代码，哦，我喜欢这样做机器学习。有人在会议上给我门展示一个例子关于，给一些人脸数据，如何训练出一个机器学习系统推断他们有什么类型的眼睛。他们有的是圆眼，还是椭圆形的眼睛，像这样的东西。显然，这会驱动你拥有化妆品或者其他种类的化妆品。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;哦，哇&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）：&lt;/h3&gt;
&lt;p&gt;这个女性做了大量的陈述，然后她说，这就是训练这个模型的代码，随后问她一些问题。然而，从头到尾只有15行代码。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）： 15:40&lt;/h3&gt;
&lt;p&gt;哇&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）：&lt;/h3&gt;
&lt;p&gt;随后你就能有一张图片，告诉你你的眼睛是什么样子。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;哦，我的天呐&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）：&lt;/h3&gt;
&lt;p&gt;那些类型的东西，这些小而超级强大的东西，你可以通过这些包带来真的是难以置信。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;哇，真的很酷&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）：&lt;/h3&gt;
&lt;p&gt;不疯狂吗？&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）： 15:56&lt;/h3&gt;
&lt;p&gt;好的，让我们先暂停一会儿。我们接下来会从迈克尔那听到更多东西，但是我想回过头来并强调一些东西。那就是是什么可能使惊人的Python占据第一的位置？是Python社区。Python的成功的决定性一部分是巨大的，响应的社区。&lt;/p&gt;
&lt;p&gt;与此同时，当我们看到范·罗素姆的离开，社区的规模依然庞大。在你身边一个完成语言的设想不得不打断。以某种方式上，想法做一个孤单的独裁者吸引如此庞大的社区是站不住脚的。范·罗素姆不需要为他的编程语言收到多大反应而准备，但是，几乎是自发地，社区成员将Python邮件列表，新闻组，网页，以及最终通过PEP讨论通过的编程语言更改过程汇集在一起。（PEP代表Python增强建议书）&lt;/p&gt;
&lt;p&gt;所以，仅凭独裁者的称号，范·罗素姆已经建立起一种真的可以与之交谈的编程语言，一种用户可以帮助建立的编程语言。我打赌凭他离开之时所受的挫折，范·罗素姆知道一个充满活力的社区给予比拿走更重要。&lt;/p&gt;
&lt;h3&gt;黛安·穆勒（Diane Mueller）： 17:25&lt;/h3&gt;
&lt;p&gt;我叫黛安·穆勒。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;黛安是红帽公司云平台开发部的总监。在过去的三十年，他目睹了开源社区力量的强大进化，并且她对Python社区印象特别深刻。&lt;/p&gt;
&lt;h3&gt;黛安·穆勒（Diane Mueller）：&lt;/h3&gt;
&lt;p&gt;Python社区所做的事情实在了不起，他们带来了对于会议的行为守则，多样的奖学金，所有这类事情的概念。通过带入不同的声音和不同的远景，我们得到将存活更久，更好，更有创新性的项目，并希望为更多人更好的工作。&lt;/p&gt;
&lt;p&gt;即使他们犯了错误，他们公开，透明地解决，在看到硅谷的和创业公司的兄弟文化有的枯萎之后通过社区合作，Python感觉像回到了我起步到地方，并且也回到了原来的社区。所以，这实在很鼓舞人心，实在太棒了。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;鼓舞人心的重要原因是Python重新定义了排在首位的那部分社区意味着什么。我提到吉多·范·罗素姆（Guido van Rossum）开始鼓励女性参加社区，即使他离开了。但是，他也帮助用普遍的方式扩大范围。&lt;/p&gt;
&lt;h3&gt;黛安·穆勒（Diane Mueller）：&lt;/h3&gt;
&lt;p&gt;个人比代码贡献给大家带来的东西更多。大多数社区管理者和项目领导着眼于使人为他们的项目做贡献，而在Python社区，人们真的高亢的鼓舞人心的去建立文档，帮助筹办会议，帮助提高多样化。作为Python社区的一部分，他们都做自己力所能力的一些事情。 &lt;br&gt;
所以，那主意，那贡献不止事关代码，它是关于参与，关于学习和教育，更多关于文档，这就是为许多人进入社区的方式。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;当然了，我们还有很长的路要走。&lt;/p&gt;
&lt;h3&gt;黛安·穆勒（Diane Mueller）：&lt;/h3&gt;
&lt;p&gt;任人唯贤还是非常注重技术。这是无疑地。但我认为你会看到对社区管理和社区管理者的信心。我们是社区技术性的一部分，相反不仅是雇佣的为我们做事的人。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;对黛安，范·罗素姆正式退出他独裁者角色的决定是全球转移的一部分。它正从一个旧的，单一庞大的语言建设离开。 &lt;/p&gt;
&lt;p&gt;我认为我们可以从这个模范身上继续，虽然偶尔我会听到有人说，我是这个项目仁慈的独裁者，而且我像，吖，我不这么认为。 &lt;/p&gt;
&lt;p&gt;黛安·穆勒是红帽公司开发部门的总监。 &lt;/p&gt;
&lt;p&gt;顺便说一下，吉多·范·罗素姆（Guido van Rossum）发送的这个令人瞠目结舌的“权利移交”备忘录，Python社区本身就是庞大的力量。项目在成长之时接受新的治理楷模，在多种方式上，正如我们看到的那样，这些人已经对掌管他们自己的语言做好准备。但是，我仍想知道，究竟是怎样做到的？在范·罗素姆离开后会发生什么？让我们继续和迈克尔·肯尼迪交流问问答案。
抛开Python，在没有他之后社区会怎样？&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）： 21:05&lt;/h3&gt;
&lt;p&gt;好吧，社区过去发展的不错，但是我们过去……在最高的水平上，有点停滞。运营和编程语言基本上进入一种迷茫的状态。那些有趣事情的提案，有时很复杂，但有时又真的简单。就像，嘿嘿，我们能每年而不是每18个月发送一次Python岂不是更好，至少有点可预测，绑定每年的会议，诸如这样的事情。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;当然，是的。&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）：&lt;/h3&gt;
&lt;p&gt;这并不能被决定，因为他离开之后没有方式做决策。他说，我去度假了。这取决于你们，你们不得不断定如何继续运行下去。我甚至不会告诉你如何决定，如何继续运行它。这现在是你们的问题了。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）： 21:48&lt;/h3&gt;
&lt;p&gt;哇。听起来很有戏剧性，但仔细想想。记得Python增强建议书，PEPs允许社区给反馈吗？好吧，让PEPs来拯救。&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）：&lt;/h3&gt;
&lt;p&gt;他们尝试决定了一系列为Python社区的新的治理模式。他们决定之一的大事件，被称作协调理事会，有五个成员——我相信他们都有同样的表决权--而且他们最近已经选举了五个出来。因此，要想成为一个人的左膀右臂，必须由他们决定。 &lt;/p&gt;
&lt;p&gt;我认为很好的一件事就是我们有吉多·范·罗素姆（Guido van Rossum）作为成员之一。他离开时说，我不能成为所有人想改变和反馈的压力唯一的来源……但是他仍然，没有从编程语言中完全脱离开。他仍然是核心开发者，他仍然在协调理事会。所以他仍然有些话语权，但是他不能完全决定，这真的很棒。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;我很好奇实际上是如何制定的，因为我觉得如果我在协调理事会而且我在编程语言的发明者身边，我可能取向于同意他所说的一切。&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）：&lt;/h3&gt;
&lt;p&gt;好吧，的确如此。在所有条件平等的条件下，更倾向于吉多。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;是的，的确。&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）：&lt;/h3&gt;
&lt;p&gt;我不知道。我知道几个在协调理事会的人，他们都是忠实的贡献者和开发者，可能即使在编程层面也要比吉多多15年。因此，他们也都紧密参与其中，也十分自以为是，那么……&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;对于投资呢？&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）： 23:25&lt;/h3&gt;
&lt;p&gt;吖，对于投资。我感觉还不错。而且我觉得吉多的多半喜好，我仍想参与其中，但他可能给人们施加他的意愿，因为那会让他回到原来的状态。我认为他可能想呆在一个更轻松的位置上。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;好吧，我很好奇，你喜欢这个有仁慈的独裁者称号的偶像吗？这个在编程语言起始阶段必不可少的，为了使它成为发展，运行，为了使其激进并取得突破性进展的偶像吗？&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）：&lt;/h3&gt;
&lt;p&gt;当然了。我认为一些事，主要的设计是归委员会的，不是超级英雄的。而在几天前，很多决策关于，语言如何工作？是否使用分号？怎样做，做什么？所有这些事情委员会很难决定，但Python至今已经超过25岁了。有如此多的人加入其中，我现在认为，他是个非常好的偶像。
他们甚至打败或者应该替换掉仁慈的独裁者，我们会选谁做为现在的统治者？但是他们决定反对。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;好吧，如果仁慈的独裁者地位如此重要，我好奇一个社区需要多久呢？听起来像吉多自己决定一样，嘿嘿，那就太多了。这不是长久之计，我也不会长久这样做。但是如果不是他来决定，我好奇的是是不是他离开的最佳时间，我们转向一点更民主的做法？&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）：&lt;/h3&gt;
&lt;p&gt;是的，过去的不是吗？我认为可能是。对一个人来说很难将社区，技术，新闻趋势的脉搏完整连接起来，可以说，40年也难出这样一个人。可能会极不相同，所以必须有此切换。我不是真的知道它在哪里，但是我感觉在有其他人比仁慈的独裁者做的更多之后产生。更多的核心贡献者和开发者，你曾经喜欢的，好吧，我休假了，而且看着这些新发生的事情，他幸存下来了。诸如此类的话。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）：&lt;/h3&gt;
&lt;p&gt;是的，就好像社区将会告诉你何时它准备好了。&lt;/p&gt;
&lt;h3&gt;迈克尔·肯尼迪（Michael Kennedy）：&lt;/h3&gt;
&lt;p&gt;正确，的确如此。&lt;/p&gt;
&lt;h3&gt;萨隆·伊特巴莱克（Saron Yitbarek）： 25:48&lt;/h3&gt;
&lt;p&gt;Python社区仍然要为自己存活下去，所以现在我们先抛开他们。迈克尔·肯尼迪是两期播客的嘉宾，会在此期间继续跟踪他们的进展。你可以查看Talk Pyton to Me 和 Python Bytes两期节目。&lt;/p&gt;
&lt;p&gt;你听过梭伦的故事吗，他以古雅典的立法者而闻名？非常了不起的一个人。在公认梭伦为雅典民主的贡献之后，他进入到一种自愿放流的状态。那是因为他知道如果他一直在权利之下就有成为暴君的危险。我猜测吉多·范·罗素姆（Guido van Rossum）就是梭伦的翻版，给我们几十年的标准做法，有点像宪法那样。这个人建立了优秀的编程语言，在这一个开源社区可以做他们自己的编程语言。然后，他也可以给他们权利移交，在此他告诉他们，你们只能靠你们自己了。我不再是你们的独裁者。 &lt;/p&gt;
&lt;p&gt;他确信做的是社区，而不是自己，并带着Python披风向前。在某种方式上，吉多·范·罗素姆（Guido van Rossum）的“权利移交”备忘录是对开源世界所有编程语言的宣言，因为任何编程语言发展自己的社区，最后的挑战只有社区能解决。 &lt;/p&gt;
&lt;p&gt;在第三季的《代码英雄》，我们深潜到编程语言的世界。编程语言获得影响力因为它们用强大的新方法解决新问题，在这季接下来的时间，我们将揭露JavaScript，Perl，COBOL，Go甚至更多语言成为超级大国的秘密。再插一句，我们将知道BASIC的故事，作为每个人的第一编程语言教会了我们什么。 &lt;/p&gt;
&lt;p&gt;如果你想了解更多Python或者你其中听到的某些东西，可以前往 &lt;em&gt;redhat.com/commandlineheroes&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;最后，我是萨隆·伊特巴莱克（Saron Yitbarek）。继续编程吧！&lt;/p&gt;</content><category term="IT"></category><category term="Tech"></category><category term="Code"></category><category term="python"></category></entry><entry><title>机器学习笔记</title><link href="https://leelongcrazy.github.io/ji-qi-xue-xi-bi-ji.html" rel="alternate"></link><published>2020-02-16T17:00:00+08:00</published><updated>2020-02-16T17:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2020-02-16:/ji-qi-xue-xi-bi-ji.html</id><summary type="html">&lt;p&gt;我为什么要接触机器学习？&lt;/p&gt;</summary><content type="html">&lt;h2&gt;我为什么要接触机器学习？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;深入了解前沿的计算机科学技术&lt;/li&gt;
&lt;li&gt;通过人工智能给自己赋能&lt;/li&gt;
&lt;li&gt;开阔思维，计算机的思维深深影响我对世界的认知&lt;/li&gt;
&lt;li&gt;我一直在想以后会不会有一个AI程序能把一个人所有的社交资料信息和他在网络上的痕迹阅读一遍，能够写出一本关于这个人自传。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;所以我开始在学台大的机器学习课程。&lt;a href=""&gt;摘录了几句关于这门课程的报道&lt;/a&gt;：&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;「AI界網紅」台大電機系李宏毅：踏入AI研究，其實是因為曾經迷惘 &lt;br&gt;
李宏毅從2015年起在台大開機器學習、深度學習的相關課程，現在的上課內容已經完全不同，「AI 技術發展的速度非常非常快，是以『週』為單位在改變，」李宏毅形容。「如果有人問我，『今天想學深度學習，該學哪一種程式語言？』我基本上傾向不回答，因為你今天才剛學好一個語言，很快又會被取代。」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="李宏毅" src="https://imgkr.cn-bj.ufileos.com/119ca3c5-3a24-4406-8ccd-0d880c90a1af.png"&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;AI時代 培養心理素質比學寫程式更重要&lt;/strong&gt; &lt;br&gt;
面對 AI 時代，想給中小學生的父母哪些建議？李宏毅沒有建議學 coding、或學好數學，而是加強「任何時候都用得上的心理素質」。他分析，在學校裡老師給的作業都是有解的，但做研究、訓練機器時，中間有太多沒法控制的因素，結果不可預期。「我們太常面對失敗了，能不能承受得了打擊？能不能夠承受得了失敗？」他發現，很多台大學生既無法接受結果不如預期，也無法接受自己的成績因此不夠好。&lt;/p&gt;
&lt;p&gt;會特別強調心理素質，也和李宏毅自身經歷有關。很難想像，講話幽默風趣的李宏毅在大二時，曾經「非常沮喪、非常迷惘」。那時他因為電機系上許多必修課感到困惑，「不確定學這些要做什麼？一度覺得念不下去，幾乎要放棄人生，想轉系或休學算了，」他回憶。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「能不能讓機器像人類一樣學習？我們始終離這目標非常遠，現在我只是站在門邊而已，但我絕對不會小看技術的發展，」&lt;/strong&gt; 李宏毅正設法帶領研究團隊，跟上最前瞻的技術。但他也不忘提醒學生終身學習的重要，&lt;strong&gt;「你現在所學的東西絕對不是終點，畢業後更要不斷努力去跟上時代。」&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;他認為，「&lt;strong&gt;未來教育最重要的是，不斷學習最前瞻的技術。&lt;/strong&gt;」今天每個人都認同的結論很有可能幾個月後就被推翻，於是他總是提醒學生，「&lt;strong&gt;今天學到的這些東西，並不是終點，因為技術隨時都在改變。&lt;/strong&gt;」&lt;/p&gt;
&lt;p&gt;AI時代下要培養學生什麼能力？李宏毅教授只有一個不變的答案，就是&lt;a href=""&gt;不斷求新與學習的能力。&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="IT"></category><category term="Tech"></category><category term="AI"></category></entry><entry><title>头号玩家观后感</title><link href="https://leelongcrazy.github.io/tou-hao-wan-jia-guan-hou-gan.html" rel="alternate"></link><published>2020-02-16T17:00:00+08:00</published><updated>2020-02-16T17:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2020-02-16:/tou-hao-wan-jia-guan-hou-gan.html</id><summary type="html">&lt;p&gt;《头号玩家》是出自斯皮尔伯格导演之手，这部片子斩获了第九十一届奥斯卡最佳视觉效果奖，剧情自不多提及，我只说说自己的观影感受。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;头号玩家观后感&lt;/h2&gt;
&lt;h5&gt;《头号玩家》是出自斯皮尔伯格导演之手，这部片子斩获了第九十一届奥斯卡最佳视觉效果奖，剧情自不多提及，我只说说自己的观影感受。&lt;/h5&gt;
&lt;h6&gt;游戏中的主角通过头戴式的眼镜进入游戏，通关以后拿到三把钥匙可以获得已故游戏开发者的所有资产。&lt;/h6&gt;
&lt;h6&gt;电影最后主角赢得了三把钥匙，可以得到将整个游戏毁掉的机会，但他并没有这么做，而反派人物却因为没能赢得游戏欲摧毁这个游戏的世界，前者是无限游戏的做法，后者是有限游戏的做法。&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;《有限与无限的游戏》是一本书来着，这本书深深影响了美团的王兴。&lt;/p&gt;
&lt;p&gt;作者：詹姆斯·卡斯，纽约大学宗教历史系的教授，是一个无神论者，他把自己的信仰描述为“着迷于不可知的作为人类的存在”。&lt;/p&gt;
&lt;p&gt;一个哲学家如何看待眼前的世界？很简单！都是游戏。作者向我们展示了两种游戏：有限的游戏，和无限的游戏。有限游戏的目的在于赢，无限游戏却想让游戏永远玩下去。有限的游戏有明确的开始和结束，而无限的游戏没有开始，没有结束，甚至没有赢家，他的目的在于将更多的人带入游戏，从而延续游戏。
谁也无法同被迫参与的人进行游戏，这是所有游戏不变的原则，有限与无限的游戏均是如此。无论谁参与，都是自愿参与，被迫参与便失去了参与的意义。
如果说符合条件的人才能参与有限游戏，那么只要愿意，谁都可以参与无限的游戏，无限的游戏并不受资格的限制。
无限游戏的过程中可以出现有限游戏，有限游戏无论输赢，在无限游戏参与者眼中不过是游戏过程的瞬间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6&gt;最后主角拿到了这部游戏作者的股份，他并没有一个人独占，而是和游戏前五名均分，这也像是一个无限游戏的做法。&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;想起小的时候打游戏，小霸王连着黑白电视机，自己家里没有，就和小伙伴偷偷溜进他们家里玩，玩的入迷中午都忘记回家了;旁边村子靠近学校的小卖部靠这样的业务赚钱，印象着两块钱可以玩上好几个小时，那时玩的游戏是坦克大战，超级马里奥，魂斗罗……&lt;/strong&gt;&lt;/p&gt;
&lt;h6&gt;以下是关于这本书的书摘：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;没有一个人能独自玩游戏。一个人不成其为人，没有群体，便没有自我。&lt;/p&gt;
&lt;p&gt;变化是我们人之为人的持续性的一个基础。只有能够变化的，才能够持续下去。&lt;/p&gt;
&lt;p&gt;世界上有两种游戏，一种称为有限的游戏，而另一种则称为无限的游戏。
有限游戏以取胜为目的，而无限游戏则以延续游戏为目的。
如果有限游戏有获胜者，那么这个游戏必须有一个明确的终结。如果所有参与者都认同其中某个人是赢家，那么这个人就赢得了游戏。有人获胜，有限的游戏便结束了。
既然有明确的终结，有限的游戏也必然有明确的开端，因此有限的游戏存在时间界限，而这个界限是所有参与者认同的。有限的游戏也存在空间界限，游戏必须在一个确定的场地进行，并由规定的参与者参与。
谁也无法同被迫参与的人进行游戏，这是所有游戏不变的原则，有限与无限的游戏均是如此。无论谁参与，都是自愿参与，被迫参与便失去了参与的意义。
无限的游戏没有明确的时空界限，没有开始，没有结束，也不存在输赢。如果说符合条件的人才能参与有限的游戏，那么只要愿意，谁都可以参与无限的游戏，无限的游戏并不受资格限制。
无限游戏的过程中可以出现有限游戏，有限游戏无论输赢，在无限游戏参与者眼中不过是游戏过程的瞬间。
有限游戏的参与者其实拥有随时离开赛场的自由，但他们中的大多数会选择留在争斗之中。在某种程度上，有限游戏参与者遮蔽了自己的自由，否则所有竞争、努力都会离他们而去。
所以从一开始，有限游戏参与者会把自己视为某个角色，而且这个角色具有严肃性。通过适当的练习，我们相信自己就是这些角色所塑造的人。甚至我们也会让他人相信，我们就是这样的人。&lt;/p&gt;
&lt;p&gt;由于有限游戏旨在达成一个结果，它的角色已经设定好，并且是在为观众表演，所以有限的游戏具有“剧本性”，有限游戏的参与者都带有表演性质。
无限游戏的参与者则会避开任何结果，对未来保持开放，让剧本作废，所以无限的游戏具有“传奇性”。
有限的游戏也可以具有传奇性，但那只是暂时的传奇性。每个有限游戏的参与者都想成为王牌参与者，技巧纯熟完美到没有什么可以令他们感到意外。因此真正的王牌参与者在参赛时就好像看到了游戏的结束，根据剧本行事，而这个剧本的每一个细节都在游戏动作之前就被揭晓——传奇性也就这样消失。&lt;/p&gt;
&lt;p&gt;人们在有限游戏中赢得的是头衔。头衔是他人对某个比赛胜利者的认可，它的效用取决于它在其他人眼中的知名度和重要性。
头衔是永恒的，但只有受到认可才有意义，因此我们必须想方设法确保人们对它的记忆。这里就不得不提到死亡对于有限与无限游戏的重要性。
死亡与肉体命运的关联方式有两种：一个人活着，但他已经死了；或者一个人死了，他依然活着。
活着但死亡指的是这个人已经停止了所有比赛，不能为头衔作进一步努力，所有与他人的竞争关系都已被遗弃，即接受失败者的身份，失去所有头衔；死了却仍然活着指的是，由于获得了头衔且头衔之永恒，头衔获得者及其头衔可能不会被死亡消灭。胜利者之永存并不是因为他们的灵魂不受死亡影响，而是因为他们的头衔永远不会被忘却。
在有限的游戏中，死亡是一种失败。有限游戏的参与者会因为另一位参与者的终结举动而死亡：如果一位参与者的界限失守，那么他就败给了对手，死亡也就降临，同时游戏宣告结束。
无限游戏的参与者也终有一死。由于死亡的界限总是游戏的一部分，无限游戏参与者并不是死于游戏结束时，而是在游戏进行的过程中死亡。无限游戏的参与者可能不知道死亡何时降临，但我们总能说“他们死在合适的时候”（尼采）。
如果有限游戏参与者因为赢得游戏而获得头衔，那么无限游戏的参与者除了自己的名字以外一无所有。
当一个人被他人以头衔相称，人们的注意力便放在了已经结束的过去，关注的是一个已经终结的游戏——这个游戏是无法重演的。头衔实际上将参与者带离了游戏。
如果一个人只因名字被人所知，人们的关注点则落在开放的未来。我们直接以姓名称呼彼此时，开放了所有能让彼此的关系变得深深互惠的可能性。我们既无法预测彼此的未来，又让彼此的未来交织在一起，充满无尽可能。你的未来和我的未来成为了我们的未来，我们让彼此为惊奇做好准备。
权力是对头衔的敬重，它是有限游戏的特征。如果说有限游戏的参与者为了权力（power）而参赛，那么无限游戏的参与者凭借力量（strength）而参赛。
有权力的人会给过去一个结果，解决悬而未决的问题；有力量的人将过去承载到未来，表明过去的问题无法得到解决。权力的数量有限，力量则无法被衡量，因为它是一种开放而非封闭的行为。
权力总是被限制在少数被选定的人之中，而任何人都能拥有力量。&lt;/p&gt;
&lt;p&gt;文化是无限的游戏，它没有任何边界。在一个文化中，所有人都能成为参与者，无论任何时间、任何地点。
社会是权力的展示，它是剧本性的。一旦有什么偏离了剧本，马上会很明显地被看出来。保证许多游戏的规则不被篡改，是社会的一项重要功能。
然而，越轨却是文化的本质。谁要是仅仅追随剧本亦步亦趋，重复过去，那就是文化上的赤贫者。
社会对抗其内部文化的一个成功方法，是给予艺术家们一块地方，将他们视为财产的生产者，于是便提高了消费艺术的价值。很明显，那些大型的艺术收藏，那些世界级的博物馆，都是民族主义高涨时期的巨富或者政府所为。比如纽约的主要博物馆都与大亨家族的姓氏联系在一起：卡内基、惠特尼、弗里克和摩根等。
这些博物馆创立的初衷不是为了艺术品免遭人民破坏，而是为了让人民免于接触艺术。
有限的游戏能够重复玩无数次，但由于无限的游戏没有时空边界的限制，所以它也无法重复。不可重复性是所有文化的典型特征。莫扎特的第四十一号交响曲不可能再创作一次，伦勃朗的自画像也不可能画两次。社会将这些作品保存起来，认为它们是那些在各自游戏中获胜者的战利品。然而文化并不将这些作品视作奋斗的产物，而认为是奋斗过程中的瞬间——文化即奋斗本身。艺术家的工作是如此原创，以至于其他人无法复制，但是却呼唤着其他人原创式的回应。
艺术从不是占有物，它永远是可能性，所以被占有物已不具有艺术身份。艺术不可能成为财产，财产使人注意到头衔，回指向一个已完成的时间。艺术则是动态的，永远向前敞开，开启了不可能终结之物。
无限的游戏有自己的规则，文化则有自己的传统。无限游戏中的规则能够自由达成或自由更改，文化传统也会被创造，并在改造中发生变化。
准确地说，文化并不是拥有一个传统，它本身就是传统。&lt;/p&gt;
&lt;p&gt;不允许过去成为过去，也许是有限游戏参与者之所以那么严肃的原因。只要有限游戏的参与者们还有观众，他们就希望观众明确谁才是获胜者。但凡还有一个观众，他们就希望这个观众是深深入戏的。
除非胜利者的头衔能被他人看到，不然这些头衔毫无价值。我们越是不被看到，就越拥有着一个被宣判为无足轻重的过去。当我们严肃地进入有限的游戏时，我们现身于一群意识到“我们不可见”的观众。因此我们有种向观众证明自己的紧迫感，证明自己不是他们所想的那样，我们想要获胜。
越是将自己视为获胜者，我们就越知道自己是失败者。这就是为什么在得到知名度相当高、被很多人觊觎的奖励品的获胜者中，很少有人满足于现有头衔而金盆洗手。获胜者，特别是知名获胜者，必须反复证明自己是获胜者——剧本必须被一遍又一遍地演出。
我们因胜利带来的可见性，只能让不可见的过去所代表的失败将我们抓得更紧。&lt;/p&gt;
&lt;p&gt;你是你自己的天才，是你说的话和做的事的创造者。原创性的言谈、行动或者思考，这是在消除自我的边界，远离剧本性的人格特质。
若我们将自己视作“自己的天才”，我们会允许让过去成为过去。自己的天才能够将我们从愤恨中解救出来，这一方法被尼采称为“遗忘的官能”，它并非对过去的否认，而是通过我们自己的原创性来重塑过去。
于是，我们并不在意观众是否记得我们。
我们想起的是自己一直拥有游戏的自由。&lt;/p&gt;
&lt;p&gt;天底下没有天才养成秘籍，一个小孩子也不可能自动变成天才。天才来自触动。触动是无限游戏中最典型的悖论现象。
触动（touch）并不是指两个人的距离减少至零。只有从发自内心、原创地回应对方时，我们才真正被触动。
触动的反面是推动（move）。你将我推向一个你预见或预备好的地方，这就是推动。推动是一种舞台化的行动。
只有成为所有剧本背后的“我本人”，我才被触动。所有设计好的东西都会被触动粉碎。触动和被触动者所感受到的无非是惊讶。
我们只有被遮蔽才能被推动，而穿过遮蔽物，我们得以被触动。&lt;/p&gt;
&lt;p&gt;有限的游戏并不拥有自身的时间，它存在于一个世界的固定时间里。观众只允许参与者消费这些时间来赢得胜利的头衔。
无限游戏参与者不消费时间，而是产生时间。因为无限游戏是传奇化的，并没有剧本化的结尾，所以它的时间是被人们生活的时间，而非被审视的时间。
无限游戏的参与者既不年轻，也不年老，因为他们并不生活在别人的时间里。对于无限游戏的参与者来说，时间并不流逝，时间的每一瞬间都是一个开始。
无限游戏的参与者开始工作，并不是为了将一段时间用工作来填充，而是为了将一段工作用时间来填满。工作不是无限游戏参与者打发时间的方式，而是产生各种可能性的方式。工作并不是抵达一个被期望的现在，而是走向一个本身具有未来的未来。
对有限游戏的参与者来说，自由也是有限的，他的自由取决于时间分配——只有一部分的时间能够分配给自由；对无限游戏的参与者来说，一切都是自由的，时间只是众多自由中的一种。&lt;/p&gt;
&lt;p&gt;无限游戏的参与者能够玩任何有限的游戏，他们也能成为任何游戏的观众。他们成为观众，同时也在观察游戏，并充分意识到他们的观众身份。他们在看，但是他们看到自己在看。
无限的游戏对于有限的观察者来说，是隐而不显的。这样的观看者寻找着一个结局，寻找着一些方式。参与者通过这些方式能够将游戏终结，完成所有未完成的事。有限游戏的参与者站在无限游戏的参与者面前，就像站在艺术面前一样，看着它，将它视为制成品。&lt;/p&gt;
&lt;p&gt;我们出于社会原因而控制自然。对自然的控制随着我们预测自然过程结果之能力的提高而提高。
对于自然的不同态度大致可以概括为这样两种：将自然看成充满敌意的他者，它的基本目的在于同我的利益为敌，这样我们会把自然视为“机器”；而当我们学会规范自己，以适应自然秩序最深的可辨模式，我们得到的结果便是“花园”。
这里所说的“机器”指的是技术的无所不包性，而非实际的技术。我们可能会为来自于发明家或工程师充满想象的技术发明而感到惊奇万分，但是技术本身并无让人惊奇之处。物理学家的核弹和穴居人的杠杆一样，完全是机械性的，都是可计算的因果序列运用。
“花园”并不是指房屋旁边或城市边上的一小块有边界的土地。它不是人们生活在旁边的花园，而是人们生活于其中的花园。它是一片生长之地，具有最大化的自生力。打理花园并不是加入一种嗜好或娱乐，而是去设计一种文化。在这种文化中，我们能够调整自己，以适应自然中可能的最大范围的惊奇。
机器和花园并不是对立的，机器可以存在于花园之中，正如有限游戏可以存在于无限游戏当中一样。
我们很熟悉一种机器化的花园，看上去似乎果实累累，但走进再看，会发现这里并不鼓励自然的自发生长，而是对自然的开发利用。机器与花园的最根本区别在于，机器是由外力驱动的，而花园是自然生长的，其能量来自于它自身。
一次成功的收割，并不是花园存在的终结，而只是它的一个阶段。所有园丁都知道，花园的生命力并不随着一次收割而结束，它只是呈现出另外一副面貌。花园在冬天并不是死去，而是静静地等待下一个季节。园丁们歌颂多样化、与众不同以及自发性，他们知道风格的丰富多彩是有利于生命力焕发的。&lt;/p&gt;
&lt;p&gt;文化也是一样，无限游戏的参与者明白，一种文化的活力，是与其来源的多样性和内部的各种差异直接相关的。一个人身上的特异性与惊奇性，并不会对另外一个人产生压制。&lt;/p&gt;
&lt;p&gt;你身上的天才，会激发我身上的天才。&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="Movie"></category><category term="Tech"></category><category term="Movie"></category></entry><entry><title>《贫穷的本质》这本书</title><link href="https://leelongcrazy.github.io/pin-qiong-de-ben-zhi-zhe-ben-shu.html" rel="alternate"></link><published>2019-11-28T17:00:00+08:00</published><updated>2019-11-28T17:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2019-11-28:/pin-qiong-de-ben-zhi-zhe-ben-shu.html</id><summary type="html">&lt;p&gt;今天快速看完了《贫穷的本质》这本书，乍一看真的以为书中会写关于贫穷的本质的东西，其实书中的大部分内容都是写关于对世界上一些相对落后贫穷国家人民生活的调查，和对一些现象的分析，对比。先前看了一个TED演讲中讲贫穷是一种人格的缺陷。&lt;/p&gt;</summary><content type="html">&lt;h4&gt;今天快速看完了《贫穷的本质》这本书，乍一看真的以为书中会写关于贫穷的本质的东西，其实书中的大部分内容都是写关于对世界上一些相对落后贫穷国家人民生活的调查，和对一些现象的分析，对比。先前看了一个TED演讲中讲贫穷是一种人格的缺陷。&lt;/h4&gt;
&lt;hr&gt;
&lt;h4&gt;以下摘录了一些有感的内容：&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;家庭规模与储蓄之间的有力联系，或许有助于说明这样一点，即&lt;strong&gt;孩子越少并不意味着他们越健康或受教育程度越高&lt;/strong&gt;——如果孩子少的父母意识到他们将来只能得到较低的现金回报，那么他们就需要提前储蓄更多的钱，这会减少他们投资给孩子的钱。的确，如果给孩子投资会比其他金融资产投资（毕竟养个孩子并不那么费钱）产生更高的回报，那么从长远角度来看，&lt;strong&gt;孩子越少，家庭或许会越穷&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;诺贝尔经济学奖得主加里·贝克对此有一个极具影响力的论断。贝克称，每个家庭都面临着一种所谓的“质与量的取舍”，也就是说，&lt;strong&gt;一旦有了更多的孩子，每个孩子的“质”就会降低，因为父母为每个孩子投入的食物及教育资源就会更少&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;南希·钱对中国独生子女政策的效果进行了调查，她发现了一个更具争议性的结果：在某些地区，这一政策较为宽松，允许第一个孩子为女孩的家庭再生一胎。南希发现，由于实行了这一政策，&lt;strong&gt;那些多了一个兄弟姐妹的女孩与独生子女相比，接受了更多的教育&lt;/strong&gt;，这显然有违贝克的理论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;我们的看法&lt;/p&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h5&gt;穷人所陷入的困境与我们其他人的困扰似乎是一样的——&lt;strong&gt;缺乏信息、信念不坚定、拖延&lt;/strong&gt;。的确，&lt;strong&gt;我们并不贫穷，受过良好的教育，见多识广，但我们与穷人的差别其实很小，因为我们的认识比我们想象中的要少得多&lt;/strong&gt;。&lt;/h5&gt;
&lt;h5&gt;我们的真正优势在于，很多东西是我们在不知不觉中得到的。我们住在有自来水的房子里，不用想着每天早晨往水里加消毒剂。下水道自行运转，我们甚至不知道是怎样运转的。我们大都相信医生会尽力为我们服务，公立医院会告诉我们该做什么，不该做什么。我们别无选择，只能让孩子接种疫苗（公立学校不接收未接种疫苗的孩子）。即使我们出于某种原因没给孩子接种疫苗，他们可能也会安全无恙，因为其他所有人都接种过了。如果我们去健身房，我们的保险公司会奖励我们，因为他们担心没有奖励我们会不去。而且，或许最重要的是，我们大多数人都无须担心是否有下一顿饭吃。换句话说，我们几乎用不着自己有限的自控及决断能力，而穷人则需要不断运用这种能力。&lt;/h5&gt;
&lt;h5&gt;我们应该认识到，谁也没有那么明智、耐心或博学到能够为自己的健康做出正确的决定。同样，对于那些生活在富裕国家的人来说，他们周围充满了无形的助推力，而贫穷国家保健政策的首要目标应该是，让穷人尽可能容易地获得预防性保健，并规范病人所能享受的医疗服务的质量。鉴于人们对价格的高度敏感性，这些国家的政府应免费提供预防性服务，或是奖励那些利用这种服务的家庭，使其尽量成为自然的“默认选择”。免费的释氯器应放在水源旁边；给自己孩子接种疫苗的家长应得到奖励；学校里的孩子们应得到免费的抗蠕虫药片和营养增补剂；至少在人口密集地区，水利及卫生设施的公共投资应立即启动。&lt;/h5&gt;
&lt;h5&gt;作为公共卫生投资，通过减少疾病与死亡、提高人们的收入，很多这类补贴的价值都超出了其自身的成本——不再反复患病的孩子可以上更长时间的学，因而可以在成年后挣更多的钱。不过，我们并不可以就此认为，这一切在没有干预的情况下会自然而然地发生。即使在预防性措施十分廉价的情况下，如果关于其好处的信息不完善，再加上人们当前的习惯，他们愿意为之付出多少努力、投入多少钱都会受到限制。而如果那些措施不那么廉价的话，他们要面对的问题自然是钱。从治疗的角度来看，这一挑战是双重的：既要确定人们可以获得自己所需要的药品，还要限制他们获取不需要的药品，从而防止药物依赖性的增长。在发展中国家，由谁来开展实践并充当医生的角色，这似乎是大多数政府都难以规范的。因此，要减少抗生素耐药性的蔓延及强效药的滥用，唯一的方法或许就是，尽最大努力控制这类药品的销售。&lt;/h5&gt;
&lt;h5&gt;这一切听上去都颇具家长式风气，不过从某种角度上来说，事实的确如此。对于生活在安全而干净的家中、躺在舒适沙发上的我们来说，痛斥家长式作风的危害、告诉自己该为自己的生活负责是轻而易举的。对于我们这些生活在富裕世界的人来说，我们目前不正是这种家长式作风的永久受益者吗？我们深深扎根于这一体系而浑然不觉。这个体系不仅可以将我们照顾得更好，而且我们也不需要去思考生活中的其他问题。然而，我们仍然有责任向人们传授公共卫生知识。我们确实欠每个人（包括穷人）一个尽可能清晰的解释，告诉他们为什么接种疫苗如此重要，为什么他们需要完成整个接种疗程。不过，我们应该真正认识到，仅凭信息并不能取得成功。这就是事物本身的规律，对于穷人来说是如此，对于我们也是一样。&lt;/h5&gt;
&lt;hr&gt;
&lt;h5&gt;书中最后的部分&lt;/h5&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h5&gt;经济学家（及其他专家）谈论哪些国家的经济在增长，哪些国家的经济没有增长，这看上去没有任何用处。一些国家由经济瘫痪转变为经济奇迹，如孟加拉国和柬埔寨；另一些国家的经济从“模范”沦落到谷底，如科特迪瓦。回顾过去，我们总能找出合理的理由解释过去发生的事情。但事实是，大多数情况下，我们很难预测哪个国家的经济会增长，也不明白为什么有些事会忽然发生。&lt;/h5&gt;
&lt;h5&gt;鉴于经济增长需要人力与智慧，但无论何时，如果男人和女人都受过良好的教育、拥有健康的身体，如果市民们在为孩子投资方面具有安全感和信心，让孩子们走出家门，到市里去找一份新工作，那么人们就更容易摆脱贫困，这看上去似乎是合理的。&lt;/h5&gt;
&lt;h5&gt;或许，到那时，人们需要长久致力于摆脱贫困。如果不幸和挫折不请自来，气愤与暴力占据上风，那么能否摆脱贫困，我们尚不可知。一种有效的社会政策可以使人们远离失败，因为他们觉得自己不会失去什么，要让国家在其所处的时代腾飞，那么这样的政策或许是关键的一步。&lt;/h5&gt;
&lt;h5&gt;如果所有这些都不正确，如果国家政策不能带来经济增长，那么尽一切可能来提高穷人的生活质量，不再等待经济刺激，将是大势所趋。第一章中对道德问题的讨论使我们在某种程度上知道了如何摆脱贫困，我们不能容忍浪费穷人的才干和生命。正如本书所讨论的，尽管我们没有根除贫困，但我们知道有些事情或许可以改善穷人的生活。具体见以下5个方面。&lt;/h5&gt;
&lt;h5&gt;第一，&lt;strong&gt;穷人通常缺少信息来源，相信那些错误的事情&lt;/strong&gt;。他们不清楚给儿童接种疫苗的好处，不明白基础教育的重要性，不知道该使用多少化肥，不知道哪种方法最易染上艾滋病，也不知道政治家们每天都在做些什么。在他们发现那些坚信不疑的信念是错误的之前，他们会做出错误的决定，这些决定有时会引起严重的后果。如果女孩们与成年男子发生性关系并且未采取避孕措施，或农民使用两倍于正常量的农药，这些事情的后果都是严重的。例如，由于人们不确定接种疫苗有哪些好处，再加上办事拖延的习惯，导致很多孩子失去了这样的机会。如果公民盲目选举，他们很可能会选择同种族的候选人，尽管这样做会使顽固和腐败问题变得更严重。&lt;/h5&gt;
&lt;h5&gt;有很多事例可以说明，一条普通的信息可以带来巨大的变化。当然，事情并不总是如此。要想产生这样的效果，这条信息必须具备以下特点：&lt;strong&gt;它必须是人们尚未知晓的&lt;/strong&gt;（如“婚前禁止性行为”是人人都知道的，效果不明显）；&lt;strong&gt;信息的发布方式必须是简单而有吸引力的&lt;/strong&gt;（电影、电视剧、精心设计的报告单）；&lt;strong&gt;信息的来源必须是可靠的&lt;/strong&gt;（有趣的是，媒体看上去似乎是可靠的）。因此，当媒体发布信息称政府做得不对，政府将花费大量的成本来挽救自己的信誉。&lt;/h5&gt;
&lt;h5&gt;第二，&lt;strong&gt;穷人肩负着生活中的多种责任&lt;/strong&gt;。你越富有，越容易做“正确”的决定。穷人没有自来水，因此，当市政府对水进行氯化时，他们不能受益。他们买不起速溶的强化营养型麦片，因此不得不想办法确保他们及自己的孩子得到足够的营养。他们没有自动扣除功能的储蓄计划，例如退休计划或社会保障，因此要想办法存些钱。做这些决定是困难的，因为它需要人们考虑当下或前期做出少量付出，而回报很可能在遥远的未来。人们拖延的习惯会把事情搞砸。对于穷人，更为麻烦的是，他们的生活本来就很困难：他们中的一些人做着竞争激烈的小本生意，剩下的大部分人打散工，总要为找到下一份工作发愁。这说明通过做正确的事情，他们的生活就会得到很大改善——降低加铁/碘盐的生产成本，使人人都买得起；银行提供存钱容易但取钱代价会稍高的储蓄账户，让每个人都能享有，如果有必要的话，政府可以对银行进行补贴，以弥补其带来的成本费用；在自来水昂贵的地方提供清毒剂以做净水处理。这样的事例还有很多。&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;针对此段内容讲“越富有，越容易做‘正确’的决定”，我还是看到有不同观点的：当你有大量钱的时候，决策的时候可能津津于现有的成就而会忽略一些潜在的风险，进而做出坏的决定，钱少的时候你才会谨小慎微更容易做出正确的决定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;第三，&lt;strong&gt;一些服务于穷人的市场正在消失，或是在这些市场中，穷人处于不利地位&lt;/strong&gt;。穷人存款所得的利息（如果有幸拥有一个账户的话）是负利息，但贷款的利息却很高。针对穷人的医疗保险市场尚未健全，尽管医疗问题给他们的生活带来了很大影响。&lt;/h5&gt;
&lt;h5&gt;在一些案例中，技术创新或制度创新可以弥补市场发展的不足，例如小额信贷市场，它向穷人发放小额贷款，利息不高，人们支付得起；又如，电子转账系统（用手机等）和个人识别系统可以在未来几年大幅削减银行成本。但是，我们还应认识到，这类市场的兴盛不仅需要靠自身的努力那么简单，有时需要政府的支持。&lt;/h5&gt;
&lt;h5&gt;我们应该认识到，这可能会产生免费赠送的产品或服务（如蚊帐或到保健中心做检查），甚至奖励人们做有利于自身的事情，虽然这听上去有些奇怪。各类专家都不信任这种免费发放的产品和服务，即使是从纯粹成本效益的角度来看，这也可能有些夸张了。相对于收取一个固定价格来说，免费向每个人提供服务的成本常常更低。在某些情况中，这可能需要确保市场所售产品的价格具有足够的吸引力，允许市场得以发展。例如，政府可以补贴保险费用、发放代金券，而家长则可以在任何一家学校（公里或私立）使用，或是强迫银行向每个人提供免费的账户，只收取象征性的费用。我们有必要记住，这些得到补贴的市场需要受到严格的监管，确保其运转良好。例如，如果所有家长都能为自己的孩子找到合适的学校，那么学校代金券就非常有用；否则，这可能会成为为精明的家长提供又一优势的方式。&lt;/h5&gt;
&lt;h5&gt;第四，&lt;strong&gt;贫穷的国家不会因为贫穷或其不堪回首的历史而注定失败&lt;/strong&gt;。的确，在这些国家，事情很难办成：一项关于帮助穷人的计划由于被某些人接手而失败了；教师教学散漫；建筑施工时偷工减料，车辆超载以致道路塌陷等。这些事件几乎与那些精英们的经济阴谋无关，主要是由于制定政策时出现的错误造成的，包括无知、意识形态和惯性。人们期望护士完成普通人无法胜任的工作，但从没有人想过修改护士的工作职责。在印度，一位政府高官曾告诉我们，村里的教育委员会成员包括优秀生的家长和差生的家长。当我们问他们如何评定好坏的标准时（直到四年级才有考试），那位官员立刻转移了话题。然而，由于惰性，这些荒唐的规定目前还在生效。&lt;/h5&gt;
&lt;h5&gt;如果表达正确的话，在不改变现有社会及政治结构的情况下，有可能对管理和政策加以改进。即使是在“良好的”制度环境下，改进的空间仍是巨大的，而在不好的环境下也有一定行动的空间。只要确保每个人都被邀请来参加村庄会议，对政府工作人员进行监督，并让他们为自身的渎职而担负起责任，对各个阶层的政治家进行监督，并将这一信息与选民分享，向公共服务用户们说明他们应期待什么——医疗保健中心的准确工作时间，他们应当拿到多少钱（或是多少袋米），那么，一次小的变革便可以实现。&lt;/h5&gt;
&lt;h5&gt;第五，&lt;strong&gt;对于人们能做什么或不能做什么，最终常变为自我实现的预言&lt;/strong&gt;。孩子们放弃上学是因为老师（有时是父母）认为他不够聪明；水果店老板不努力还贷是因为他们认为自己还会负债；护士不上班是因为没人对她们在岗位上的表现抱有期望。改变人们的期望是不容易的，却并不是不可能的：当看到村里出现了女官员时，村民们不仅不再歧视女政治家，甚至开始认为自己的女儿也具备这种发展潜力。更重要的是，成功能带来更大的成功。当一种情况得到改善时，这种改善本身就会影响人们的信念和行为。因此，在启动一个良性循环时，人们不应害怕必要的付出（包括现金）。&lt;/h5&gt;
&lt;h5&gt;除了上述5个原因，我们还有很多本该知道却不知道的事情。这本书旨在对这些问题抛砖引玉。如果我们拒绝懒惰和公式化的思考模式，如果我们倾听穷人的心声，理解他们的逻辑，那么我们就能制定一套有效的政策，也能更理解穷人的生活方式。基于这种理解，我们可以发现贫穷的原因，并找到解决的办法。&lt;/h5&gt;
&lt;h5&gt;关于宏观经济政策和体制改革，我们不想做过多评论，但也不会忽略这项事业所暗藏的逻辑：小的变化可以带来大的影响。肠道寄生虫可能是你最不想提的话题，但是肯尼亚的孩子为此需要在学校接受治疗，时间长达两年，而不是一年（成本是每年每个孩子1.36美元），他们成年后平均每年多挣20%，即一个人一生多挣3 269美元。如果杀虫工作更加广泛，它所带来的影响会更小：如果肠道寄生虫被消灭，那些孩子可能早已投入了工作。我们注意到，2006—2008年，肯尼亚人均收入可持续增长率创历史新高，为4.5%。如果我们撬动经济政策的杠杆，那么该地经济会呈现前所未有的增长，4年内人均收入将提高20%，但是，这样的杠杆并不存在。&lt;/h5&gt;
&lt;h5&gt;&lt;strong&gt;我们不能保证消除贫困。一旦我们承认这一点，我们就获取了充足的时间。贫困已跟随了我们几千年，如果我们打算在50年或100年内消除贫困，那就行动起来。至少我们不能再假装已找到了解决的办法，我们应与全球其他人一起联手努力，让这个世界再没有人每天依靠99美分生活。&lt;/strong&gt;&lt;/h5&gt;</content><category term="Books"></category><category term="Article"></category></entry><entry><title>AI简述</title><link href="https://leelongcrazy.github.io/aijian-shu.html" rel="alternate"></link><published>2019-07-16T17:00:00+08:00</published><updated>2019-07-16T17:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2019-07-16:/aijian-shu.html</id><summary type="html">&lt;p&gt;阅读AI笔记部分内容摘录&lt;/p&gt;</summary><content type="html">&lt;h1&gt;AI简述&lt;/h1&gt;
&lt;p&gt;&lt;img alt="image" src="./images/image2.png"&gt;&lt;/p&gt;
&lt;h3&gt;广义的人工智能是指“通过计算机实现人类思维的效果，能从环境中获取感知并行动“ 的现象。&lt;/h3&gt;
&lt;h3&gt;我们大致可以把广义人工智能分为弱人工智能和强人工智能。&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;弱人工智能&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;处理特定的问题，并不具有人类感知能力。弱人工智能包含了机器学习，机器学习又包括了深度学习。&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;强人工智能&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;是具备与人类同等智慧或超越人类的人工智能，能表现正常人类所具有的所有智能行为。&lt;/h3&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;计算机科学与软件工程的明显区别&lt;/h2&gt;
&lt;h3&gt;下图展示了两者的区别：&lt;/h3&gt;
&lt;p&gt;&lt;img alt="image" src="./images/image6.png"&gt;&lt;/p&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;学习AI建议&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;有科学家素养的工程师&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在AI领域具备&lt;em&gt;源头创新能力&lt;/em&gt;，具备解决企业关键技术难题的能力&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;源头创新能力:如果要培养源头创新能力，那么就需要打开一些黑盒子，刨根问底，而不能满足于仅仅会调用一些函数，使用一些现成的工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;核心能力是什么&lt;/h2&gt;
&lt;h3&gt;我们要培养的能力是计算思维，是：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;观察，找到事物变化的模式和规律；&lt;/li&gt;
&lt;li&gt;逻辑的组织和分析数据；&lt;/li&gt;
&lt;li&gt;把问题解法变为有组织，可重复的步骤；&lt;/li&gt;
&lt;li&gt;把问题解法抽象，变为更通用，应用在更多领域。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;强调&lt;em&gt;动手+动脑&lt;/em&gt;，不要急于学习最时髦的东西，而是要把基础数学和基础编程学习好，锻炼高质量的工程能力，自己提出问题，自己解决问题。&lt;/h3&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;p&gt;文章摘抄来源：&lt;a href="https://github.com/microsoft/ai-edu/blob/master/B-%E6%95%99%E5%AD%A6%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/B0-introduction/AI301_intro.md"&gt;&lt;span class="underline"&gt;https://github.com/microsoft/ai-edu/blob/master/B-教学案例与实践/B0-introduction/AI301_intro.md&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;</content><category term="TECH"></category><category term="Tech"></category><category term="AI"></category><category term="it"></category></entry><entry><title>Python一行代码建立HTTP服务</title><link href="https://leelongcrazy.github.io/pythonyi-xing-dai-ma-jian-li-httpfu-wu.html" rel="alternate"></link><published>2019-06-17T17:00:00+08:00</published><updated>2019-06-17T17:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2019-06-17:/pythonyi-xing-dai-ma-jian-li-httpfu-wu.html</id><summary type="html">&lt;p&gt;在Python语言中有一条可在本机快速建立http服务的命令，可实现与他人分享存在你电脑的上的文件&lt;/p&gt;</summary><content type="html">&lt;h4&gt;在Python语言中有一条可在本机快速建立http服务的命令，可实现与他人分享存在你电脑的上的文件。&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python -m SimpleHTTPServer
&lt;span class="c1"&gt;# 默认开启8000端口，后面可跟数字指定端口&lt;/span&gt;
Serving HTTP on &lt;span class="m"&gt;0&lt;/span&gt;.0.0.0 port &lt;span class="m"&gt;8000&lt;/span&gt; ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;浏览器打开，IP：Port即可实现该目录下的浏览，文件下载。&lt;/h4&gt;
&lt;hr&gt;
&lt;h4&gt;今天配置&lt;code&gt;.ssh/config&lt;/code&gt;文件时候还犯了一个可笑的错误。在config文件中配置管理密钥的格式如下：&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Hostname github.com
User git
IdentityFile ~/.ssh/github

Host aliyun
Hostname xx.xx.xx.xx
User xxx
IdentityFile ~/.ssh/aliyun

Host linux
Hostname localhost
Port &lt;span class="m"&gt;9999&lt;/span&gt;
User root
IdentityFile ~/.ssh/linux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;我将&lt;code&gt;IdentityFile&lt;/code&gt;错误的打成了&lt;code&gt;IdentifyFile&lt;/code&gt;，结果一直爆下面的错误：&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;.ssh/config: line &lt;span class="m"&gt;40&lt;/span&gt;: Bad configuration option: identifyfile
.ssh/config: terminating, &lt;span class="m"&gt;1&lt;/span&gt; bad configuration options
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;在网上搜索了好多结果，最终看到一文章提示有可能将单词打错导致的，才得以修正过来。原来&lt;code&gt;identity&lt;/code&gt;是 &lt;em&gt;身份&lt;/em&gt;的意思， &lt;code&gt;identify&lt;/code&gt;是 &lt;em&gt;鉴定，辨认&lt;/em&gt;的意思。配置中需要的是 &lt;code&gt;身份文件&lt;/code&gt;，而不是我理解的&lt;code&gt;鉴定文件&lt;/code&gt;。&lt;/h4&gt;</content><category term="IT"></category><category term="Code"></category><category term="Python"></category></entry><entry><title>俞军的PM12条方法论</title><link href="https://leelongcrazy.github.io/yu-jun-de-pm12tiao-fang-fa-lun.html" rel="alternate"></link><published>2019-06-11T18:00:00+08:00</published><updated>2019-06-11T18:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2019-06-11:/yu-jun-de-pm12tiao-fang-fa-lun.html</id><summary type="html">&lt;p&gt;滴滴俞军的PM12条方法论，收藏学习&lt;/p&gt;</summary><content type="html">&lt;h1&gt;俞军的PM12条方法论&lt;/h1&gt;
&lt;h4&gt;俞军，百度贴吧之父，近期从滴滴离职，是滴滴产品的严格把关者。&lt;/h4&gt;
&lt;p&gt;&lt;img alt="yu" src="./images/yu.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://baike.baidu.com/item/%E4%BF%9E%E5%86%9B/5349#viewPageContent"&gt;滴滴出行顾问、百度原产品副总裁&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.PM首先是用户&lt;/p&gt;
&lt;p&gt;2.站在用户角度看待问题&lt;/p&gt;
&lt;p&gt;3.用户体验是一个完整的过程&lt;/p&gt;
&lt;p&gt;4.追求效果，不做没用的东西。&lt;/p&gt;
&lt;p&gt;5.发现需求，而不是创造需求。&lt;/p&gt;
&lt;p&gt;6.决定不做什么，往往比决定做什么更重要。&lt;/p&gt;
&lt;p&gt;7.用户是很难被教育的，要迎合用户，而不是改变用户。&lt;/p&gt;
&lt;p&gt;8.关注最大多数用户，在关键点上超越竞争对手，快速上线，在实践中不断改进。&lt;/p&gt;
&lt;p&gt;9.给用户稳定的体验预期&lt;/p&gt;
&lt;p&gt;10.如果不确定该怎么做，就先学别人是怎么做的。&lt;/p&gt;
&lt;p&gt;11.把用户当傻瓜，不要让用户思考和选择，替用户预先想好。&lt;/p&gt;
&lt;p&gt;12.不要给用户不想要的东西，任何没用的东西对用户都是一种伤害。&lt;/p&gt;</content><category term="TECH"></category><category term="TECH"></category></entry><entry><title>GitHub配置SSH</title><link href="https://leelongcrazy.github.io/githubpei-zhi-ssh.html" rel="alternate"></link><published>2019-05-30T17:00:00+08:00</published><updated>2019-05-30T17:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2019-05-30:/githubpei-zhi-ssh.html</id><summary type="html">&lt;p&gt;对github账号配置ssh密钥对实现远程推送&lt;/p&gt;</summary><content type="html">&lt;h2&gt;GitHub配置SSH&lt;/h2&gt;
&lt;hr&gt;
&lt;h3&gt;在使用GitHub配置ssh的时候吃了好多苦头，整理了下完整的操作过程&lt;/h3&gt;
&lt;h4&gt;必备工具，操作是在Linux系统环境下完成的&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Bash&lt;/li&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;li&gt;GitHub账号&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;在使用Git工具之前需要对&lt;code&gt;git config&lt;/code&gt;进行配置&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ git config --global user.email &lt;span class="s2"&gt;&amp;quot;xxx@xxx.com&amp;quot;&lt;/span&gt;
$ git config --global user.name &lt;span class="s2"&gt;&amp;quot;user-name&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;在&lt;code&gt;~/.ssh/&lt;/code&gt;目录下创建一对公私密钥&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ssh-keygen
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;执行完后会在当前目录下生成两个新的文件，将后缀名.pub的公约内容复制到Github个人账号-&amp;gt; settings -&amp;gt; SSH and GPG Kyes -&amp;gt; New SSH key文本框中，点击&lt;code&gt;Add SSH key&lt;/code&gt;添加密钥；并对添加的公钥命个别名。&lt;/h4&gt;
&lt;h4&gt;在终端执行下面命令：&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ &lt;span class="nb"&gt;eval&lt;/span&gt; &lt;span class="sb"&gt;`&lt;/span&gt;ssh-agent -s&lt;span class="sb"&gt;`&lt;/span&gt; &lt;span class="c1"&gt;#注意是反单引号&lt;/span&gt;
$ ssh-add 私钥文件名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;测试：&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ssh -T git@github.com 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;测试成功显示：&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ Hi user-name! You&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;ve successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;接着push代码，发现仍需要输入用户名和密码，执行下面的命令， &lt;strong&gt;注意连接域名和用户名之间的符号是 &lt;code&gt;:&lt;/code&gt;,而不是 &lt;code&gt;/&lt;/code&gt;&lt;/strong&gt;，删除远程仓库重新建立连接&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ git remote rm origin
$ git remote add origin git@github.com:user-name/repository-name.git 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;接下来远程推送的时候不再需要输入的用户名和密码。&lt;/h4&gt;</content><category term="IT"></category><category term="Tech"></category><category term="Git"></category></entry><entry><title>电影《绿皮书》观后感</title><link href="https://leelongcrazy.github.io/dian-ying-lu-pi-shu-guan-hou-gan.html" rel="alternate"></link><published>2019-05-28T17:00:00+08:00</published><updated>2019-05-28T17:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2019-05-28:/dian-ying-lu-pi-shu-guan-hou-gan.html</id><summary type="html">&lt;p&gt;观影后感&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Green Book&lt;/h1&gt;
&lt;h2&gt;电影《绿皮书》观后感&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;钢琴三重奏&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;乐曲题材或演奏形式之一，由钢琴，小提琴，大提琴组成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4&gt;电影根据真实历史改编，主角之一托尼·利普一开始是俱乐部的安保一样的职位，靠混社会谋生活，后来成为黑人钢琴家唐·雪莉的司机，随他一路南下表演，充当安全保护的角色，当时的历史背景黑人依然受到白人的歧视。&lt;/h4&gt;
&lt;h4&gt;电影展现的的两个人之间的阶级冲突，肤色冲突，一个是通过钢琴演奏成为了富裕阶层，一个生活仍得不到保障，甚至需要通过在餐厅和别人通过打赌吃热狗来谋生活费用。&lt;/h4&gt;
&lt;h4&gt;在南下的路上，两个人因为生活习惯的不同而互相看不惯，不能理解对方。托尼吃相，随意的行为在雪莉看来很难忍受，雪莉一身整齐的仪表，谈吐尽显雅致，细节过于拘谨在唐尼眼中不以为然。雪莉试图改变唐尼的言语和行为，但一路上听他讲述关于自己的故事，在自己遇到麻烦的时候唐尼总是能化解危机渐渐而开始慢慢理解他了，唐尼在每次演出时观看雪莉在台上的演奏渐渐被雪莉的音乐感染，像走进了他的内心一样，开始欣赏这个自己不以为意的音乐家。&lt;/h4&gt;
&lt;h4&gt;演出的最后一站，发生了小小的冲突，雪莉要在一个餐厅表演，但因为肤色的原因却不能在这家餐厅用餐，他采用了唐尼的处事习惯，强硬回应了店主的无理要求，造成合同违约了。&lt;/h4&gt;
&lt;h4&gt;两个人完全是不同的生活哲学，在相处的过程中慢慢相互渗透，能形成这样的结果，因为两个人都是有&lt;code&gt;同理心&lt;/code&gt;的，通过这一段奇妙的经历彼此促进双方的心智成熟，最终唐尼赢得了更融洽的家庭环境，雪莉走出了个人的孤独，感受到爱的力量。&lt;/h4&gt;
&lt;h4&gt;善良对待身边的每一个人，人生那么长，能在某一个时空下相遇多么难得的机会，《山河故人》里的的台词“每个人都只能陪你走一段路”，感谢一路有你，才能让我看到最靓的风景。&lt;/h4&gt;</content><category term="Movie"></category><category term="Article"></category></entry><entry><title>Git使用指南</title><link href="https://leelongcrazy.github.io/gitshi-yong-zhi-nan.html" rel="alternate"></link><published>2019-05-28T17:00:00+08:00</published><updated>2019-05-28T17:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2019-05-28:/gitshi-yong-zhi-nan.html</id><summary type="html">&lt;p&gt;github常用命令解析&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Git使用指南&lt;/h1&gt;
&lt;h2&gt;看懂Git命令，搞懂版本控制&lt;/h2&gt;
&lt;h3&gt;Git，版本控制必备手段，程序员黑客Linus Benedict Torvalds发明了这个有名的版本控制工具，他还是Linux内核的发明人和这个计划的合作者。&lt;/h3&gt;
&lt;h3&gt;&lt;code&gt;git init&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;这是创建一个新的项目要做的第一件事，在项目文件目录下创建一个&lt;code&gt;.git&lt;/code&gt;的存储库（隐藏文件夹），存储库（repo）是你对项目文件的修改按照时间顺序存储的集合，记录下所有更改的记录。&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;git config&lt;/code&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$:git config --global user.name &lt;span class="s2"&gt;&amp;quot;Your name&amp;quot;&lt;/span&gt;
$:git config --global user.email &lt;span class="s2"&gt;&amp;quot;YourEmail@xxx.com&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;用来设置你提交时候需要设置的信息，只在Git安装之后设置一次就可以了。&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;git add filename&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;可以添加任何你想添加的文件到暂存区（staging area）。&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;git add .&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;可以将项目文件夹下所有文件放到暂存区，而不用一个一个添加。&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;git status&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;显示所有你已经放进暂存区的文件，和进行了修改需要放进暂存区的文件。&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;git reset filename&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;从暂存区删除指定文件&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;git rm --cached filename&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;从暂存区删除指定文件，并将其设置为未跟踪。&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;git commit -m "Description of the commit"&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;从暂存区获取文件，并将它们提交到本地存储库。引号部分为修改文件的描述，注意一定要写的简单清晰，不可省略。&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;touch .gitignore&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;创建一个名叫.gitignore的文件，可以通过文本编辑的方式写下存储库需要忽略的文件名或文件夹名，运行时候这些被忽略的文件不会显示。&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;git branch branchName&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;创建一个代码分支，就是前一个分支代码库的直接副本。如果不加分支名字可以列出当前代码库的分支情况，前面带有&lt;code&gt;*&lt;/code&gt;号的分支即为你当前所在分支。&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;git checkout "branchName"&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;检查你创建的分支，并在这个分支上工作，通俗的讲就是分支切换。&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;git merge branchName&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;这个命令把分支&lt;code&gt;branchName&lt;/code&gt;合并到当前分支。&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;git remote add origin https://github.com/UserName/projectName.git&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;添加远程存储库的位置。在此之前的操作都是在本地完成，此步需要登录GitHub账号创建一个远程存储库，然后把本地存储库的文件放上去。创建远程存储库之后会生成一个链接，可以放在上面的命令中。&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;git remote&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;和项目关联的远程存储库列表。&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;git push -u origin master&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;将本地存储库推送到远程存储库，第一次执行命令时直接这样写就好。&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;git push&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;在执行完初始推送后把代码刚到GitHub上。&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;git clone https://github.com/userName/projectName.git&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;将项目远程仓库的代码clone到你本地计算机。&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;git clone -b branchName https://github.com/userName/projectName.git&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;将远程仓库&lt;code&gt;branchName&lt;/code&gt;分支的代码clone到本地计算机。&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;git add -A &amp;amp;&amp;amp; git commit -a -m "description" &amp;amp;&amp;amp; git push --all&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;一行命令搞定代码提交。&lt;/h4&gt;
&lt;h3&gt;&lt;code&gt;git pull&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;如果你和别人用一样的代码库，这个命令可以让你从远程存储库获取最新版本，更新你的本地版本，这样就可以在别人的基础上继续写代码了。&lt;/h4&gt;</content><category term="IT"></category><category term="Tech"></category><category term="Git"></category></entry><entry><title>VIM注释代码与反注释</title><link href="https://leelongcrazy.github.io/vimzhu-shi-dai-ma-yu-fan-zhu-shi.html" rel="alternate"></link><published>2018-02-28T17:00:00+08:00</published><updated>2018-02-28T17:00:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2018-02-28:/vimzhu-shi-dai-ma-yu-fan-zhu-shi.html</id><summary type="html">&lt;p&gt;VIM注释代码与反注释&lt;/p&gt;</summary><content type="html">&lt;h2&gt;VIM注释代码与反注释&lt;/h2&gt;
&lt;h3&gt;方法一： 块选择模式注释&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;按键“V”进入 &lt;em&gt;visual模式&lt;/em&gt;，选中需要注释的代码行；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl + V&lt;/code&gt;  进去 &lt;em&gt;块选择模式&lt;/em&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;I&lt;/code&gt;进入插入模式，输入注释符号 “#” 或者 “//”...；&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;立即按下&lt;code&gt;ESC&lt;/code&gt;键两次，即可注释完成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;取消注释&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ctrl + V&lt;/code&gt;  进去 &lt;em&gt;块选择模式&lt;/em&gt;；&lt;/li&gt;
&lt;li&gt;选择要删除的注释符号，按&lt;code&gt;d&lt;/code&gt;删除即可&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;方法二：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;批量注释&lt;ul&gt;
&lt;li&gt;&lt;code&gt;：开始行号，结束行号/s/^/注释符号/g&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;取消注释&lt;ul&gt;
&lt;li&gt;&lt;code&gt;：开始行号，结束行号/s/^注释符号//g&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[参考链接：https://blog.csdn.net/xiajun07061225/article/details/8488210]（https://blog.csdn.net/xiajun07061225/article/details/8488210）&lt;/p&gt;</content><category term="IT"></category><category term="Vim"></category><category term="Code"></category></entry><entry><title>My first Article</title><link href="https://leelongcrazy.github.io/My-first-post.html" rel="alternate"></link><published>2017-11-26T10:01:00+08:00</published><updated>2017-11-27T12:30:00+08:00</updated><author><name>leelongcrazy</name></author><id>tag:leelongcrazy.github.io,2017-11-26:/My-first-post.html</id><summary type="html">&lt;p&gt;First Post&lt;/p&gt;</summary><content type="html">&lt;p&gt;This is the &lt;em&gt;first post&lt;/em&gt; from my Pelican blog. &lt;strong&gt;YAY!&lt;/strong&gt;&lt;/p&gt;</content><category term="Article"></category><category term="Article"></category></entry></feed>